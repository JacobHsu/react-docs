{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2020/08/10/react-hooks-usememo.html","result":{"data":{"markdownRemark":{"html":"<h2 id=\"useeffect\"><a href=\"#useeffect\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h2>\n<p><strong>useEffect 一般用於處理狀態更新導致的 side effects</strong>。雖然說不提倡面向生命週期函數編程，但是在沒有熟練掌握 useEffect 的時候，類比 Class Component 的生命週期函數最能幫助我們快速上手了。useEffect 可以看成 componentDidMount / componentDidUpdate / componentWillUnmount 這 3 個生命週期函數的替代。</p>\n<p>這裡貼一個官網的例子，可以非常全面的展示 useEffect 的使用方式：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> useState<span class=\"token punctuation\">,</span> useEffect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 該組件定時從服務器獲取好友的在線狀態</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">FriendStatus</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isOnline<span class=\"token punctuation\">,</span> setIsOnline<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">function</span> <span class=\"token function\">handleStatusChange</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">status</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setIsOnline</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">.</span>isOnline<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 在瀏覽器渲染結束後執行</span>\n    ChatAPI<span class=\"token punctuation\">.</span><span class=\"token function\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 在每次渲染產生的 effect 執行之前執行</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">cleanup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      ChatAPI<span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    \n   <span class=\"token comment\">// 只有 props.friend.id 更新了才會重新執行這個 hook</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>props<span class=\"token punctuation\">.</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isOnline <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Loading...'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> isOnline <span class=\"token operator\">?</span> <span class=\"token string\">'Online'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'Offline'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"uselayouteffect\"><a href=\"#uselayouteffect\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useLayoutEffect</h2>\n<p><code class=\"gatsby-code-text\">useEffect</code> 是官方推薦拿來代替 <code class=\"gatsby-code-text\">componentDidMount</code> / <code class=\"gatsby-code-text\">componentDidUpdate</code> / <code class=\"gatsby-code-text\">componentWillUnmount</code> 這 3 個生命週期函數的，但其實他們並不是完全等價，useEffect 是在瀏覽器渲染結束之後才執行的，而這三個生命週期函數是在瀏覽器渲染之前同步執行的，React 還有一個官方的 hook 是完全等價於這三個生命週期函數的，叫 <code class=\"gatsby-code-text\">useLayoutEffect</code>。</p>\n<p>這兩者的區別可以看一下這個例子（<a href=\"https://link.zhihu.com/?target=https%3A//codepen.io/Lxylona/pen/xxOgzoV\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">codePen</a>）</p>\n<p>這個例子可以很明顯看出 useEffect 和 useLayoutEffect 之間的區別，useEffect 是在瀏覽器重繪之後才異步執行的，所以點擊按鈕之後按鈕上的數字會先變成 0，再變成一個隨機數；而 useLayoutEffect 是在瀏覽器重繪之前同步執行的，所以<strong>兩次 setCount 合並到 300 毫秒後的重繪裡了</strong>。</p>\n<p>因為 useEffect 不會阻塞瀏覽器重繪，而且平時業務中我們遇到的絕大多數場景都是時機不敏感的，比如取數、修改 dom、事件觸發/監聽…… </p>\n<p>所以首推用 <code class=\"gatsby-code-text\">useEffect</code> 來處理 side effects，性能上的表現會更好一些。</p>\n<h2 id=\"componentwillreceiveprops\"><a href=\"#componentwillreceiveprops\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ComponentWillReceiveProps</h2>\n<p>ComponentWillReceiveProps 是在組件接收到新 props 時執行的，和 useEffect 的執行時機完全不一致，事實上它和 useMemo 才是執行時機一致的，但是為什麼卻推薦用 useEffect 而不是 useMemo 來替代它呢？</p>\n<p>我們來看看一個典型的 Class Component 可能會在 willReceiveProps 裡做什麼事情：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">componentWillReceiveProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>queryKey <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>queryKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 觸發外部狀態變更</span>\n    nextProps<span class=\"token punctuation\">.</span><span class=\"token function\">setIsLoading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 取數</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reFetch</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>queryKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>value <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// state 更新</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      checkList<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getCheckListByValue</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>instanceId <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>instanceId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 事件 / dom</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'instanceId_changed'</span><span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">.</span>instanceId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這些代碼是不是很眼熟？ ComponentWillReceiveProps 經常被拿來：</p>\n<ol>\n<li>觸發回調，造成外部狀態變更</li>\n<li>事件監聽和觸發、dom 的變更</li>\n<li>重新取數</li>\n<li>state 更新</li>\n</ol>\n<p>很明顯前 3 種情況是時機不敏感的，為什麼我們習慣在 ComponentWillReceiveProps 中做這些事情呢？因為 ComponentWillReceiveProps 可以第一時間拿到 props 和 nextProps ，方便我們做對比，而現在 React 已經接管了這個對比的工作，我們完全可以使用 useEffect 來替代，不阻塞瀏覽器重渲染，用戶會覺得頁面更加流暢。像取數這種經常涉及到復雜計算的場景，更是如此。</p>\n<p>對於第 4 種情況我們需要思考一下，在組件更新期間更新狀態是否是一個恰當的行為？歸根到底組件需要動態根據某個 prop 來生成某個數據，\n如果在 Class Component 中，直接在 render 方法中生成即可，\n完全不需要 setState；如果是在 Function Component 中，確實是一個適合使用 useMemo 的場景，但是注意我們不是想要“更新狀態”，而是因為“依賴改變了所以對象更新了”。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// 當 props.params 更新時，重新生成 newParams</span>\n<span class=\"token keyword\">const</span> checkList <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n \n  <span class=\"token comment\">// 復雜的計算之後得到新的 checkList</span>\n  <span class=\"token keyword\">const</span> newCheckList <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">each</span> <span class=\"token operator\">=></span> <span class=\"token operator\">...</span><span class=\"token punctuation\">)</span>\n  \n  <span class=\"token keyword\">return</span> newCheckList\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>props<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"usememo\"><a href=\"#usememo\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo</h2>\n<p><strong>useMemo 是拿來保持一個對象引用不變的。</strong> useMemo 和 useCallback 都是 React 提供來做性能優化的。比起 classes， Hooks 給了開發者更高的靈活度和自由，但是對開發者要求也更高了，因為 Hooks 使用不恰當很容易導致性能問題。</p>\n<p>比如我有這樣一段 JSX：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">LineChart</span></span> \n  <span class=\"token attr-name\">dataconfig</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// 取數配置</span>\n    <span class=\"token operator\">...</span>dataConfig<span class=\"token punctuation\">,</span>\n    datasetId<span class=\"token operator\">:</span> <span class=\"token function\">getDatasetId</span><span class=\"token punctuation\">(</span>queryId<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span> \n  <span class=\"token attr-name\">fetchData</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newDataConfig</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// fetcher</span>\n    <span class=\"token function\">realFetchData</span><span class=\"token punctuation\">(</span>newDataConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span> \n<span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>LineChart 會在 dataConfig 發生變化時重新取數，如果 LineChart 是一個 Class Component，那他的代碼一般會這麼寫：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// Class Component</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LineChart</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  \n  <span class=\"token function\">componentWillReceiveProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 當 dataConfig 發生變化時重新取數</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>dataConfig <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>dataConfig<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      nextProps<span class=\"token punctuation\">.</span><span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>dataConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果用 Hooks 來實現，那麼代碼就變成了這樣：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// Function Component</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">LineChart</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> dataConfig<span class=\"token punctuation\">,</span> fetchData <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \n  React<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>dataConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>dataConfig<span class=\"token punctuation\">,</span> fetchData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>從上面的代碼中很明顯看出 Class Component 和 Function Component 在開發心智上的區別，在 Class Component 中我們需要自己管理依賴。</p>\n<p>比如上面的例子我們會手動判斷前後 dataConfig 是否發生了變化，如果發生了變化再重新取數；而在 Function Component 中我們把依賴交給 React 自動管理了，雖然減少了手動做 diff 的工作量，但也帶來了副作用：因為 React 做的是淺比較( Object.is() )，所以<strong>當 fetchData 的引用變化了，也會導致重新取數。</strong></p>\n<p>但這個重取數邏輯上其實是合理的， 因為對於 React 來說，<strong>任何一個依賴項改變了都應該重新處理 hooks 中的邏輯</strong>，如果一個依賴的函數改變了，有可能是確實是函數體已經改變了。這和 React 的 callback ref 的處理方法是一致的: 如果每次傳一個變化的 callback，那麼 React 認為你需要重新處理這個 ref，因此他會重新初始化 ref。</p>\n<p>雖然 React 對於依賴的處理是合理的，但是也需要解決引用變化導致的性能問題，這時候解法：\n想辦法讓 fetchData 的引用不變化。官方提供了一個 hooks —— <code class=\"gatsby-code-text\">useCallback</code> 來解決函數引用的問題。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> fetchData <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newDataConfig</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">realFetchData</span><span class=\"token punctuation\">(</span>newDataConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>realFetchData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">LineChart</span></span> \n  <span class=\"token attr-name\">dataconfig</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// 取數配置</span>\n    <span class=\"token operator\">...</span>dataConfig<span class=\"token punctuation\">,</span>\n    datasetId<span class=\"token operator\">:</span> <span class=\"token function\">getDatasetId</span><span class=\"token punctuation\">(</span>queryId<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span> \n  <span class=\"token attr-name\">fetchData</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>fetchData<span class=\"token punctuation\">}</span></span> \n<span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>這時候還沒有徹底解決問題，因為<strong>只要 props 更新</strong>，LineChart 還是每次都會重新取數，你應該已經發現了，\ndataConfig 也是一個每次都會引用變化的 prop。memo 是 Hooks 中最容易被忽略的了，即使大家有意不在 JSX 中做計算，也經常會出現這種情況：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> fetchData <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newDataConfig</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">realFetchData</span><span class=\"token punctuation\">(</span>newDataConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>realFetchData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> dataCOnfig <span class=\"token operator\">=</span> <span class=\"token function\">getDataConfig</span><span class=\"token punctuation\">(</span>queryid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">LineChart</span></span> \n  <span class=\"token attr-name\">dataconfig</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>dataConfig<span class=\"token punctuation\">}</span></span> \n  <span class=\"token attr-name\">fetchData</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>fetchData<span class=\"token punctuation\">}</span></span> \n<span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>函數式編程就這種習慣，大家已經習慣這種無狀態的寫法，但是組件就是有狀態的，狀態更新了就得重新處理相關邏輯、重新渲染。\n我們得告訴 React 什麼時候應該重新處理這個狀態了</p>\n<p><code class=\"gatsby-code-text\">useMemo</code> 就是拿來做這個的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> fetchData <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newDataConfig</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">realFetchData</span><span class=\"token punctuation\">(</span>newDataConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>realFetchData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> dataConfig <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>dataConfig<span class=\"token punctuation\">,</span>\n    datasetId<span class=\"token operator\">:</span> <span class=\"token function\">getDatasetId</span><span class=\"token punctuation\">(</span>queryId<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>getDatasetId<span class=\"token punctuation\">,</span> queryId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">LineChart</span></span> \n  <span class=\"token attr-name\">dataconfig</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>dataConfig<span class=\"token punctuation\">}</span></span> \n  <span class=\"token attr-name\">fetchData</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>fetchData<span class=\"token punctuation\">}</span></span> \n<span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>這樣 dataConfig 只有在 getDatasetId 或者 queryId 變化時才會重新生成，LineChart 只會在必要的時候才會重新取數。</p>\n<p>useMemo example : pancake-frontend/src/<a href=\"https://github.com/pancakeswap/pancake-frontend/blob/develop/src/index.tsx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">index.tsx</a></p>\n<h3 id=\"memo\"><a href=\"#memo\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>memo</h3>\n<p>你可能會發現你已經很注意用 useMemo 和 useCallback 來進行性能優化了，但是效果卻不如人意。</p>\n<p>只用 useMemo 和 useCallback 來做性能優化可能是無法得到預期效果的，原因是如果 props 引用不會變化，子組件不會重新渲染，但它依然會重新執行，看下面這個例子（<a href=\"https://link.zhihu.com/?target=https%3A//codepen.io/Lxylona/pen/dyXNBEe\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">codePen</a>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> count <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Counter 重新執行了！'</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token comment\">// ...進行了一堆很復雜的計算！</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>stateAutoChange<span class=\"token punctuation\">,</span> setStateAutoChange<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  React<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setStateAutoChange</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span> <span class=\"token operator\">=></span> s <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>stateAutoChange<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token punctuation\">{</span><span class=\"token comment\">/* count 是不會變化的 */</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Counter</span></span> <span class=\"token attr-name\">count</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果 Counter 計算量很大，那瓶頸就不是重渲染而是重執行的這個過程了。如果想要阻斷 Counter 重新執行，React 提供了一個 API：memo，它相當於 PureComponent，是一個高階組件，默認對 props 做一次淺比較，如果 props 沒有變化，則子組件不會重新執行。</p>\n<p>那麼給 Counter 套上 memo：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> Counter <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> count <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Counter 重新執行了！'</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// ...進行了一堆很復雜的計算！</span>\n  \n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>什麼時候應該用 memo 和 useMemo？\n我們可能只有在復雜應用中才會關注到性能問題（某些簡單的應用可能永遠都不會出現性能問題- -），我的看法是：</p>\n<p>用 useMemo 和 useCallback 來控制子組件 props 的引用，和 memo 一起使用效果是最佳的，原因上面的例子也呈現了，子組件會有重新執行的開銷，沒有配套 memo 的話還可能出現反效果，這幾個 API 各司其職，性能優化是一個整體的過程，不是單獨在某一個組件裡面做一些操作就可以得到改善的</p>\n<p>具體策略也是根據具體情況來，只要記住幾個 API 的功能就可以了：\n<code class=\"gatsby-code-text\">useMemo</code> 避免頻繁的昂貴計算，<code class=\"gatsby-code-text\">useCallback</code> 讓 shouldComponentUpdate 可以正常發揮作用，memo 就是 shouldComponentUpdate。</p>\n<p>References: <a href=\"https://zhuanlan.zhihu.com/p/268802571\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React Hooks: 深入剖析 useMemo 和 useEffect</a> </p>","excerpt":"useEffect useEffect 一般用於處理狀態更新導致的 side effects。雖然說不提倡面向生命週期函數編程，但是在沒有熟練掌握 useEffect 的時候，類比 Class Component 的生命週期函數最能幫助我們快速上手了。useEffect 可以看成 componentDidMount / componentDidUpdate / componentWillUnmount 這 3 個生命週期函數的替代。 這裡貼一個官網的例子，可以非常全面的展示 useEffect 的使用方式： useLayoutEffect  是官方推薦拿來代替  /  /  這 3 個生命週期函數的，但其實他們並不是完全等價，useEffect 是在瀏覽器渲染結束之後才執行的，而這三個生命週期函數是在瀏覽器渲染之前同步執行的，React 還有一個官方的 hook 是完全等價於這三個生命週期函數的，叫 。 這兩者的區別可以看一下這個例子（codePen） 這個例子可以很明顯看出 useEffect 和 useLayoutEffect 之間的區別，useEffect…","frontmatter":{"title":"React Hooks: useMemo vs useEffect","next":null,"prev":null,"author":[{"frontmatter":{"name":"Dan Abramov","url":"https://twitter.com/dan_abramov"}},{"frontmatter":{"name":"Jacob Hsu","url":"https://github.com/JacobHsu"}}]},"fields":{"date":"August 10, 2020","path":"content/blog/2020-08-10-react-hooks-usememo.md","slug":"/blog/2020/08/10/react-hooks-usememo.html"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"React components for react"},"fields":{"slug":"/blog/2021/09/03/react-components.html"}}},{"node":{"frontmatter":{"title":"npm react-copy-to-clipboard light-toast"},"fields":{"slug":"/blog/2021/06/08/react-copy-to-clipboard.html"}}},{"node":{"frontmatter":{"title":"Class Component Input Bug"},"fields":{"slug":"/blog/2020/12/21/class-component-input-bug.html"}}},{"node":{"frontmatter":{"title":"material-ui/icons"},"fields":{"slug":"/blog/2020/10/20/material-ui-icons.html"}}},{"node":{"frontmatter":{"title":"Introducing the New JSX Transform"},"fields":{"slug":"/blog/2020/09/22/introducing-the-new-jsx-transform.html"}}},{"node":{"frontmatter":{"title":"React Hooks: useMemo vs useEffect"},"fields":{"slug":"/blog/2020/08/10/react-hooks-usememo.html"}}},{"node":{"frontmatter":{"title":"React v16.13.0"},"fields":{"slug":"/blog/2020/02/26/react-v16.13.0.html"}}}]}},"pageContext":{"slug":"/blog/2020/08/10/react-hooks-usememo.html"}},"staticQueryHashes":[]}