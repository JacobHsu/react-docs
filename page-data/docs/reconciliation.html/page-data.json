{"componentChunkName":"component---src-templates-docs-js","path":"/docs/reconciliation.html","result":{"data":{"markdownRemark":{"html":"<p>React 提供聲明式 (declarative) 的 API，讓開發者在使用 React 時，可以不用關注每次 Component 更新時底層有什麼改變。這讓開發應用程式簡單許多，但也可能讓開發者對 React 底層的相關實作不夠瞭解。因此在這篇文章中描述了實作 React 底層中「diffing」演算法時，我們採取什麼策略讓 component 的更新是可預測的，同時可以滿足要求高效能的應用程式。</p>\n<h2 id=\"motivation\"><a href=\"#motivation\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>動機 </h2>\n<p>在使用 React 時，每次呼叫 <code class=\"gatsby-code-text\">render()</code> 函式，我們都可以當成是建立了一顆由 React element 構成的樹狀結構。而在每一次有 state 或 props 更新時，<code class=\"gatsby-code-text\">render()</code> 函式就會回傳一顆不同的 tree。因此，React 需要判斷如何有效率的把 UI 從舊的 tree 更新成新的 tree。</p>\n<p>對於這個「如何用最少操作去將舊的 tree 轉換成新的 tree」的演算法問題有一些通用的解法，但即使是目前<a href=\"https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">最先進的演算法</a>都還需要 O(n<sup>3</sup>) 的時間複雜度（n 為 tree 中 element 的數量）。</p>\n<p>假設 React 使用這種演算法，則呈現 1000 個 element 需要 10 億次的比較。因為這個比較成本實在太高，所以 React 在以下兩個假設下採用了一個 O(n) 的啓發式 (heuristic) 演算法：</p>\n<ol>\n<li>兩個不同類型的 element 會產生出不同的 tree</li>\n<li>開發者可以通過 <code class=\"gatsby-code-text\">key</code> prop 來指出哪些子 element 在不同的 render 下能保持不變；</li>\n</ol>\n<p>而事實上，以上假設在幾乎所有實務上會出現的場景都成立。</p>\n<h2 id=\"the-diffing-algorithm\"><a href=\"#the-diffing-algorithm\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Diffing 演算法 </h2>\n<p>當比對兩顆 tree 時，React 首先比較兩棵 tree 的 root element。不同類型的 root element 會有不同的處理方式。</p>\n<h3 id=\"elements-of-different-types\"><a href=\"#elements-of-different-types\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>比對不同類型的 Element </h3>\n<p>當比對的兩個 root element 為不同類型的元素時，React 會將原有的 tree 整顆拆掉並且重新建立起新的 tree。例如，當一個元素從 <code class=\"gatsby-code-text\">&lt;a></code> 變成 <code class=\"gatsby-code-text\">&lt;img></code>、從 <code class=\"gatsby-code-text\">&lt;Article></code> 變成 <code class=\"gatsby-code-text\">&lt;Comment></code>、或從 <code class=\"gatsby-code-text\">&lt;Button></code> 變成 <code class=\"gatsby-code-text\">&lt;div></code> 時，都會觸發一個完整的重建流程。</p>\n<p>當拆掉一顆 tree 時，舊的 DOM 節點會被銷毀，且該 component instance 會執行 <code class=\"gatsby-code-text\">componentWillUnmount()</code> 函式。當建立一顆新的 tree 時，新建立的 DOM 節點會被插入到 DOM 中，且該 component instance 會依次執行 <code class=\"gatsby-code-text\">UNSAFE_componentWillMount()</code> 與 <code class=\"gatsby-code-text\">componentDidMount()</code> 方法。而所有跟之前舊的 tree 所關聯的 state 也會被銷毀。</p>\n<p>任何在 root 以下的 component 也會被 unmount，它們的狀態會被銷毀。例如，當比對以下變更時：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"gatsby-code-xml\"><code class=\"gatsby-code-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Counter</span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Counter</span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>React 會 destroy 舊的 <code class=\"gatsby-code-text\">Counter</code> 並且重新建立一個新的。</p>\n<blockquote>\n<p>筆記：</p>\n<p>下列方法已過時，你在寫新程式應<a href=\"/react-docs/blog/2018/03/27/update-on-async-rendering.html\">避免使用他們</a>：</p>\n<ul>\n<li><code class=\"gatsby-code-text\">UNSAFE_componentWillMount()</code></li>\n</ul>\n</blockquote>\n<h3 id=\"dom-elements-of-the-same-type\"><a href=\"#dom-elements-of-the-same-type\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>比對同一類型的 DOM Element </h3>\n<p>當比對兩個相同類型的 React element 時，React 會保留 DOM 節點，只比對及更新有改變的 attribute。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"gatsby-code-xml\"><code class=\"gatsby-code-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>before<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>stuff<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>after<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>stuff<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>透過比對這兩個 element，React 知道只需要修改 DOM 節點上的 className。</p>\n<p>當更新 <code class=\"gatsby-code-text\">style</code> 時，React 僅更新有所更變的屬性。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"gatsby-code-xml\"><code class=\"gatsby-code-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>{{color:</span> <span class=\"token attr-name\">'red',</span> <span class=\"token attr-name\"><span class=\"token namespace\">fontWeight:</span></span> <span class=\"token attr-name\">'bold'}}</span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>{{color:</span> <span class=\"token attr-name\">'green',</span> <span class=\"token attr-name\"><span class=\"token namespace\">fontWeight:</span></span> <span class=\"token attr-name\">'bold'}}</span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>透過比對這兩個 element，React 知道只需要修改 <code class=\"gatsby-code-text\">color</code> 的樣式，而不需修改 <code class=\"gatsby-code-text\">fontWeight。</code></p>\n<p>在處理完目前節點之後，React 會繼續對 children 進行遞迴處理。</p>\n<h3 id=\"component-elements-of-the-same-type\"><a href=\"#component-elements-of-the-same-type\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>比對同類型的 Component Element </h3>\n<p>當一個 component 更新時，該 component 的 instance 保持不變，這樣 state 能夠被保留在不同次的 render 中。React 會更新該 component instance 的 props 以跟最新的 element 保持一致，並且呼叫該 instance 的 <code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps()</code> 、 <code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code> 和 <code class=\"gatsby-code-text\">componentDidUpdate()</code> 方法。</p>\n<p>接下來，該 instance 會再呼叫 <code class=\"gatsby-code-text\">render()</code> 方法，而 diff 算法將會遞迴處理舊的結果以及新的結果。</p>\n<blockquote>\n<p>筆記：</p>\n<p>下列方法已過時，你在寫新程式應<a href=\"/react-docs/blog/2018/03/27/update-on-async-rendering.html\">避免使用他們</a>：</p>\n<ul>\n<li><code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code></li>\n<li><code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps()</code></li>\n</ul>\n</blockquote>\n<h3 id=\"recursing-on-children\"><a href=\"#recursing-on-children\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>對 Children 進行遞迴處理 </h3>\n<p>在預設條件下，當遞迴處理 DOM 節點的 children 時，React 只會同時遍歷兩個 children 的 array，並在發現差異時，產生一個 mutation。</p>\n<p>例如，當在 children 的 array 尾端新增一個 element 時，在這兩個 tree 之間的轉換效果很好：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"gatsby-code-xml\"><code class=\"gatsby-code-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>first<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>second<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>first<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>second<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>third<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>React 會先匹配兩個 <code class=\"gatsby-code-text\">&lt;li>first&lt;/li></code> 對應的 tree，然後匹配第二個元素 <code class=\"gatsby-code-text\">&lt;li>second&lt;/li></code> 對應的 tree，最後插入第三個元素 <code class=\"gatsby-code-text\">&lt;li>third&lt;/li></code> 的 tree。</p>\n<p>如果只是單純的實作，則在 array 開頭插入新元素會讓效能變差。例如，在兩個 tree 之間的轉換效果很差：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"gatsby-code-xml\"><code class=\"gatsby-code-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Duke<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Villanova<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Connecticut<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Duke<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Villanova<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>這個情況下，React 會針對每個 child 都進行 mutate，而不是讓兩個相同的 <code class=\"gatsby-code-text\">&lt;li>Duke&lt;/li></code> 和 <code class=\"gatsby-code-text\">&lt;li>Villanova&lt;/li></code> subtree 不參與 mutate。這種低效率的情況下可能會帶來效能問題。</p>\n<p><strong>Keys</strong></p>\n<p>為了解決以上問題，React 提供了 key 屬性。當 children 擁有 <code class=\"gatsby-code-text\">key</code> 屬性時，React 使用 key 來匹配原有 tree 上的 children 以及後續 tree 的 children。例如，以下範例在新增 <code class=\"gatsby-code-text\">key</code> 屬性之後，可以改善在上個例子中發生的效能問題：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"gatsby-code-xml\"><code class=\"gatsby-code-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2015<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Duke<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2016<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Villanova<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2014<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Connecticut<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2015<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Duke<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2016<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Villanova<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>現在 React 知道只有帶著 <code class=\"gatsby-code-text\">'2014'</code> key 的 element 是新的，而帶著 <code class=\"gatsby-code-text\">'2015'</code> 以及 <code class=\"gatsby-code-text\">'2016'</code> key 的 element 只是相對位置移動了。</p>\n<p>實際上，找出一個 key 通常並不困難。你要顯示的 element 可能已經具有唯一的 ID 了，這個 key 可能是來自於你的資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>當以上情況不成立時，你可以新增一個 ID 字串到你的 Model 中，或者利用一部分內容作為 hash 來產生一個 key。這個 key 不需要是全域唯一，但在 array 中需要保持唯一。</p>\n<p>最後，你也可以使用元素在 array 中的索引值作為 key。這個方法在元素不進行重新排序時比較合適，但如果有順序修改，diff 就會變慢。</p>\n<p>當使用 array 索引值作為 key 的 component 進行重新排序時，component state 可能會遇到一些問題。由於 component instance 是基於它們的 key 來決定是否更新以及重複使用，如果 key 是一個索引值，那麼修改順序時會修改目前的 key，導致 component 的 state（例如不受控制輸入框）可能相互篡改導致無法預期的變動。</p>\n<p>下面是一個在 Codepen 上的範例，<a href=\"/redirect-to-codepen/reconciliation/index-used-as-key\" target=\"_blank\" rel=\"noreferrer\">示範使用索引值作為 key 時導致的問題</a>，以及<a href=\"/redirect-to-codepen/reconciliation/no-index-used-as-key\" target=\"_blank\" rel=\"noreferrer\">一個修復了重新排列、排序、以及在 array 開頭插入的問題，且不使用索引值作為 key 的版本</a>。</p>\n<h2 id=\"tradeoffs\"><a href=\"#tradeoffs\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>權衡 </h2>\n<p>請記得 Reconciliation 只是一個實作細節，即使 React 在每個動作後之後對整個應用進行重新 render，得到的最終結果也會和進行 Reconciliation 後是一樣的。在這個情形下，重新 render 表示在所有 component 內呼叫 <code class=\"gatsby-code-text\">render</code>，這不代表 React 會 unmount 或重新 mount 它們。React 只會基於以上提到的規則來決定如何進行差異的合併。</p>\n<p>我們會定期改善啟發式演算法，讓常見的使用場景能夠更有效率地執行。在目前的實作中，可以理解為一棵 subtree 能在其相同階層的兄弟之間移動，但不能移動到其他位置。如果移動到其他位置，則演算法會重新 render 整棵 subtree。</p>\n<p>由於 React 依賴啓發式的演算法，因此當以下假設沒有得到滿足，效能將會有所影響。</p>\n<ol>\n<li>該演算法不會嘗試匹配不同 component 類型的 subtree。如果你發現你在兩種不同類型的 component 中切換，但輸出非常相似的內容，建議把它們改成同一類型。實際上，我們沒有發現在改成同一種類型後會發生問題。</li>\n<li>Key 應該具有穩定、可預測、以及 array 內唯一的特質。不穩定的 key（例如透過 <code class=\"gatsby-code-text\">Math.random()</code> 隨機生成的）會導致許多 component instance 和 DOM 節點被不必要地重新建立，這可能導致效能低下和 child component 中的 state 丟失。</li>\n</ol>","frontmatter":{"title":"Reconciliation","next":null,"prev":null},"fields":{"path":"content/docs/reconciliation.md","slug":"docs/reconciliation.html"}}},"pageContext":{"slug":"docs/reconciliation.html"}},"staticQueryHashes":[]}