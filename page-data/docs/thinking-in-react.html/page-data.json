{"componentChunkName":"component---src-templates-docs-js","path":"/docs/thinking-in-react.html","result":{"data":{"markdownRemark":{"html":"<p>在我們的意見中，React 是用 JavaScript 建立大型、快速的網路應用程式最首要的方式。它對於在 Facebook 和 Instagram 的我們來說能很有效的增加規模。</p>\n<p>React 眾多的優點之ㄧ是它讓你能在寫程式的同時去思考你的應用程式。在這個章節中，我們會帶領你走過一遍用 React 來建立一個可搜尋的產品資料表格的思考過程。</p>\n<h2 id=\"start-with-a-mock\"><a href=\"#start-with-a-mock\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>從視覺稿開始 </h2>\n<p>想像一下我們已經有個 JSON API 和一個設計師給我們的產品視覺稿。這個視覺稿看起來像這樣：</p>\n<p>\n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 228px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 121.42857142857144%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAIAAAB1KUohAAAACXBIWXMAABYlAAAWJQFJUiTwAAACZUlEQVQ4y4VU23KqQBD0/z8nL0bjJeId8aggctOggmDQIypKFIVNy6ZSpiKkH6aWWXpnenZmM4SQKIqud7g8AvzkFzJguq673+89z4M9HA4fP+H7Pix2f/Nv5OVyaRgG7Gq12m635BFOpxPiPyDjbHAcx/FibDYb2OPxCLvb7fYx8APiB0GAU7CgWdzI2EPker3e6XQURanVao1GAwt42u02bKvVYllWVVWe5yuVCn5AmjcyLRhNA+dhHYYh9VALZxgjivG9+CLLsowjNU2zbZt6kSSyGI/Hi8WCJONGFkUxm81yHIdUqRdCms3mYDDA1h9kRNB1HWGhSo8hCAKCT6dTOO91PSAj51wu1+v1EKdYLHa7XeSMT9RpOBz+QZ7NZvP5HDl/i8QNgTaZTHAc1fKQn6HlAR85j0Yjmic04yA4kblpmmlk1FkUhImmqYoiiSKaAJFRP/ghHneTVjDTtkfTqWIYqmFopnmNew5MSICcJMFfZNLpkNdX0mwShokYBva/rrc5TpYk3Ba0pKVNLIugqiiMphH8qmmnw+FN1y3LgmBMSxq5VK0+vbxUOS7PMBWWLaM/Wq0UqT/IK8cxZjPn/d00DKzXjmNbFgbwvs+T21OS+jyvyvIYZRdFSZZHolgoFDBStEnT0j5igm17vdt9XC62aTrLJd4WCMaEr9drrFOrXauR52dSKKDmEcsSz1u5bpVhELzf76Nhkzr8Rg48L/R94rrRdntGnOv1fD7TmHhM0H94QBIjC5iHUukfz/eHw3nc23go0GHlchkTks/nISExMkrqx8DjRL3wBDHOMZKu7ROsMUWkc+uRSQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"視覺稿\"\n        title=\"\"\n        src=\"/static/1071fbcc9eed01fddc115b41e193ec11/d4770/thinking-in-react-mock.png\"\n        srcset=\"/static/1071fbcc9eed01fddc115b41e193ec11/65ed1/thinking-in-react-mock.png 210w,\n/static/1071fbcc9eed01fddc115b41e193ec11/d4770/thinking-in-react-mock.png 228w\"\n        sizes=\"(max-width: 228px) 100vw, 228px\"\n      />\n    </span>\n  </span>\n  </p>\n<p>我們的 JSON API 則會回傳一些看起來像這樣的資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"gatsby-code-text\"><code class=\"gatsby-code-text\">[\n  {category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"},\n  {category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"},\n  {category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"},\n  {category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"},\n  {category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"},\n  {category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"}\n];</code></pre></div>\n<h2 id=\"step-1-break-the-ui-into-a-component-hierarchy\"><a href=\"#step-1-break-the-ui-into-a-component-hierarchy\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>第一步：將 UI 拆解成 component 層級 </h2>\n<p>首先，你要做的是將視覺稿中每一個 component （及 subcomponent）都圈起來，並幫它們命名。如果你在跟設計師合作的話，他們可能已經幫你做好這一步了，所以跟他們聊聊吧！他們在 Photoshop 中所用的圖層的名字可能可以作為你的 React component 的名字！</p>\n<p>但是你要怎麼知道哪一個東西應該是自己獨立一個 component 呢？使用和你決定建立一個新的 function 或 object 一樣的準則即可。其中一個技巧是<a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">單一職責原則</a>，它的意思是：在我們的理想中，一個 component應該只負責做一件事情。如果這個 component 最後變大了，你就需要再將它分成數個更小的 subcomponent 。</p>\n<p>由於你常常會展示 JSON 的資料模型給使用者，你會發現，如果你的模式是正確地被建立的話，你的 UI（以及你的 component 結構）會很好的相互對應。這是因為 UI 和資料模型通常是遵守同樣的<em>資訊架構</em>，這意味著將你的 UI 拆成 component 通常是相當容易的。將 UI 分解成數個 component，每一個都明確代表著你的資料模型中的某一部份即可。</p>\n<p>\n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 275px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 116.1904761904762%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAABYlAAAWJQFJUiTwAAADjklEQVQ4y32UaXOjOBCG5///mZ1PM9lsbMcXvsExxge+MPbY5pIQCCTOHuFM1klt1cKDqqXiVR+0+AbiKjOArBr/H/hEtVJ+ExanxHY5wsxDAl6B/wPirscEnscsh0dBCGVSiUnAAlomacqTjPH0K4kgZkmS5kUJeVEFyhJAfgLAKzENE+Szk2k4tm1ZtzAMREhlUYgH7pYg4bzKr6zEPAWffIiDkAVRTikRSoyRT3xBFFGxizACMfo4pCHj7D5GX8WEB0FBkD9T1KW2Xi30N0VdLzf6aiuPp8KeyjPzcNrqe3mkLLUlpYXvp+/iHNNAtbDuoSONtz7Z+sE+CNcu2mBi0Ggf0ENA9yQUi8IwQrpwA4dQAFGwIsMgwr39ePnRkBraei6yyiEfKP1a+0VdzzLIWMk48ARE3iLkhAL1CwfyTIhzr7idGB9t9ur5Mt4d9pjojreynOnxpNseAUBliQHeEdMzpG7uQpFWnhHYS4S+//wpyZO61H1qNBqSJIznVlNeaGGWeVGE4ljgxTGJ2C6hTuFCnv7x7J+OW13X5uqbolzOZyiL2VRZzOfyZHzY79KEi9rHEY2jkMUscH/h5Ca8Vp7d0mJb/VenZXZam3+ePWUCp+NRTLtto9WM9RVcznA2Pzjxo45S648YgYU360G9pvZ743ZTHQ4gIItOW2s114MeEB8cG1znjg2exy+Hh9gBu1gt4O8naDag9gLPTzAZHXqS0Zd2nbanzYW4vF7gdr1j8fPuIXbBIsbBrddCqRv0pLDVpOvV21xV3qbyVDHMYxhRLNouEO3mkzB0vcvnsO05xs/dbn04bIxGjfH4ddC3bLtqZtEKWUY5i0TNEk4TLu5DHtuPape3m3XtjwZjeSLP3maaJquzvjyZLjRFm+/OJxRRJyBuGAi8kF59C2X2u2chtuLDbtXr7qeypa+XUvesyGq9tm63Vq1XZ70EJF65gW2BfQPHuef88amc0ioOO/j+F7w2oPkK4xFgbzMaKvWaPuhrnVZqXQEjsQUgFzBm1+OXgiWbVSR1smEv7UvRsAemcei09NeaIbWNbis/7uF8/MDk5uM7VzlT8yj3B7OJvFksieuJU7CdqauJshxPFuOJOPHVuRCnI2bAM+5eUdVheSW28wtiN983PWwgZPjkhH0T+SYmJ/RufIJgU7jycvtebfG/SQkvHjAxlkFl5J/Wxcq/FKTIiPiB/gZ6RfG+cqwoSwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Component 架構圖\"\n        title=\"\"\n        src=\"/static/eb8bda25806a89ebdc838813bdfa3601/6b2ea/thinking-in-react-components.png\"\n        srcset=\"/static/eb8bda25806a89ebdc838813bdfa3601/65ed1/thinking-in-react-components.png 210w,\n/static/eb8bda25806a89ebdc838813bdfa3601/6b2ea/thinking-in-react-components.png 275w\"\n        sizes=\"(max-width: 275px) 100vw, 275px\"\n      />\n    </span>\n  </span>\n  </p>\n<p>你會看到在這裡我們應用程式中有五個 component。我們把每個 component 所代表的資料都斜體化了。</p>\n<ol>\n<li><strong><code class=\"gatsby-code-text\">FilterableProductTable</code>（橘色）：</strong> 包含整個範例</li>\n<li><strong><code class=\"gatsby-code-text\">SearchBar</code>（藍色）：</strong> 接收所有 <em>使用者的輸入</em></li>\n<li><strong><code class=\"gatsby-code-text\">ProductTable</code>（綠色）：</strong> 展示並過濾根據<em>使用者輸入</em>的<em>資料集</em></li>\n<li><strong><code class=\"gatsby-code-text\">ProductCategoryRow</code>（土耳其藍色）：</strong> 為每個<em>列別</em>展示標題</li>\n<li><strong><code class=\"gatsby-code-text\">ProductRow</code>（紅色）：</strong> 為每個<em>產品</em>展示一列</li>\n</ol>\n<p>如果你看看 <code class=\"gatsby-code-text\">ProductTable</code>，你會發現表格的標題列（內含「Name」和「Price」標籤 ）並非獨立的 component。要不要把它們變成 component 這個議題完全是個人的喜好，正反意見都有。在這邊的例子裡面，我們把它當作 <code class=\"gatsby-code-text\">ProductTable</code> 的一部分，因為它是 rendering <em>資料集</em> 的一部分，而這正是 <code class=\"gatsby-code-text\">ProductTable</code> 這個 component 的責任。然而，如果標題欄之後變得越來越複雜（假如我們要加上可以分類的直觀功能的話），那麼建立一個獨立的 <code class=\"gatsby-code-text\">ProductTableHeader</code> component 就非常合理。</p>\n<p>既然我們已經找出視覺稿中的 component 了，讓我們來安排它們的層級。在視覺稿中，在另一個 component 中出現的 component 就應該是 child：</p>\n<ul>\n<li>\n<p><code class=\"gatsby-code-text\">FilterableProductTable</code></p>\n<ul>\n<li><code class=\"gatsby-code-text\">SearchBar</code></li>\n<li>\n<p><code class=\"gatsby-code-text\">ProductTable</code></p>\n<ul>\n<li><code class=\"gatsby-code-text\">ProductCategoryRow</code></li>\n<li><code class=\"gatsby-code-text\">ProductRow</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"step-2-build-a-static-version-in-react\"><a href=\"#step-2-build-a-static-version-in-react\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>第二步：在 React 中建立一個靜態版本 </h2>\n<p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"BwWzwm\" data-default-tab=\"js\" data-user=\"lacker\" data-embed-version=\"2\" class=\"codepen\">在 <a href=\"http://codepen.io\">CodePen</a> 中看<a href=\"https://codepen.io/gaearon/pen/BwWzwm\">用 React 思考：第二步</a>。</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n<p>在你有了 component 層級後，就可以開始實作你的應用程式了。最簡單的方式是為你的應用程式建立一個接收資料模型、render UI 且沒有互動性的版本。建立一個靜態版本需要打很多字，但不需要想很多，而加上互動性則相反，需要做很多的思考，很少的打字，所以最好的方式是把這幾個過程都分開來。接下來，我們會知道為什麼是如此。</p>\n<p>為你的應用程式建立一個 render 資料模型的版本，你會想要建立可以重複使用其他 component 的 component，並使用 <em>props</em> 傳遞資料。<em>Props</em> 是將資料從 parent 傳給 child 的方式。如果你對於 <em>state</em> 的概念很熟悉的話，請<strong>完全不要使用 state</strong> 來建立這個靜態版本。State 是保留給互動性的，也就是會隨時間改變的資料。既然我們目前要做的是這應用程式的靜態版本，你就不需要 state。</p>\n<p>你可以從最上層開始，或從最下層開始。也就是說，你可以先從層級較高的 component 開始做起（也就是從 <code class=\"gatsby-code-text\">FilterableProductTable</code> 開始），或者你也可以從比它低層級的（<code class=\"gatsby-code-text\">ProductRow</code>）開始。在比較簡單的例子中，通常從上往下是比較簡單的。但在較為大型的專案中，從下往上、邊寫邊測試則比較容易。</p>\n<p>在這一步的最後，你會有一個函式庫的可重複使用的 component 來 render 你的資料模型。這些 component 只會有 <code class=\"gatsby-code-text\">render()</code> 方法，因為這是你應用程式的靜態版本。最高層級的 component (<code class=\"gatsby-code-text\">FilterableProductTable</code>) 會接收你的資料模型作為 prop。如果你改變底層的資料模型並再次呼叫 <code class=\"gatsby-code-text\">ReactDOM.render()</code> 的話，那麼 UI 就會被更新。你可以看到 UI 的更新方式以及更改的位置。React 的 <strong>單向資料流</strong>（也可稱為<em>單向綁定</em>）確保所有 component 都是模塊化且快速的。</p>\n<p>如果你需要幫助來執行這一步的話，請參考這份 <a href=\"/docs/\">React 文件</a>。</p>\n<h3 id=\"a-brief-interlude-props-vs-state\"><a href=\"#a-brief-interlude-props-vs-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>簡短的插曲：Props 和 State </h3>\n<p>React 中有兩種「模型」資料： props and state。理解兩者的差別至關重要。若你不確定兩者的差別，請瀏覽 <a href=\"/docs/state-and-lifecycle.html\">React 的官方文件</a>以及 <a href=\"/docs/faq-state.html#what-is-the-difference-between-state-and-props\">FAQ：props 和 state 有何不同？</a>。</p>\n<h2 id=\"step-3-identify-the-minimal-but-complete-representation-of-ui-state\"><a href=\"#step-3-identify-the-minimal-but-complete-representation-of-ui-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>第三步：找出最少（但完整）的 UI State 的代表 </h2>\n<p>為了將你的 UI 變成有互動性，你需要有辦法觸發底層的資料模型做出改變。React 使用 <strong>state</strong> 把這件事實現了。</p>\n<p>為了正確地建立你的應用程式，你首先需要思考你的應用程式最少需要哪些可變的 state。這裡的關鍵是 <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DRY：<em>避免重複代碼原則</em></a>。請找出你的應用程式所需的最少的呈現方式，並在你遇到其他東西時再計算它們。例如，如果你在建立一個待辦清單，使用一個可以用來代表待辦事項的 array。不要另外用一個獨立的 state 變數來追蹤數量。當你要 render 代辦事項的數量時，讀取待辦事項 array 的長度即可。</p>\n<p>思考我們範例中應用程式的所有資料。我們現在有：</p>\n<ul>\n<li>原本的產品列表</li>\n<li>使用者輸入的搜尋關鍵字</li>\n<li>checkbox 的值</li>\n<li>篩選過後的產品列表</li>\n</ul>\n<p>讓我們來看一下每一個資料，並找出哪一個是 state。對於每一個資料，問你自己這三個問題：</p>\n<ol>\n<li>這個資料是從 parent 透過 props 傳下來的嗎？如果是的話，那它很可能不是 state。</li>\n<li>這個資料是否一直保持不變呢？如果是的話，那它很可能不是 state。</li>\n<li>你是否可以根據你的 component 中其他的 state 或 prop 來計算這個資料呢？如果是的話，那它一定不是 state。</li>\n</ol>\n<p>原本的產品列表是被當作 prop 往下傳的，所以它不是 state。搜尋關鍵字和 checkbox 看起來可能是 state，因為它們會隨時間而改變，也不能從其他東西中被計算出來。最後，篩選過後的產品列表不是 state，因為它能透過結合原本的產品列表、搜尋關鍵字和checkbox 的值被計算出來。</p>\n<p>所以，我們的 state 是：</p>\n<ul>\n<li>使用者輸入的搜尋關鍵字</li>\n<li>checkbox 的值</li>\n</ul>\n<h2 id=\"step-4-identify-where-your-state-should-live\"><a href=\"#step-4-identify-where-your-state-should-live\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>第四步：找出你的 State 應該在哪裡 </h2>\n<p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"qPrNQZ\" data-default-tab=\"js\" data-user=\"lacker\" data-embed-version=\"2\" class=\"codepen\">在 <a href=\"http://codepen.io\">CodePen</a> 中看<a href=\"https://codepen.io/gaearon/pen/qPrNQZ\">用 React 思考：第四步</a>。</p>\n<p>OK，所以我們已經找出這個應用程式最少的 state 是哪些了。下一步，我們需要找出哪幾個 component 會 mutate，或者<em>擁有</em>，這個 state。</p>\n<p>請記得，React 的核心精神是單向資料流，從 component 的層級從高往下流。也許哪個 component 該擁有 state 在一開始並不是很明顯。<strong>對新手來說，這往往是最難理解的概念</strong>，所以請跟著以下的步驟來思考：</p>\n<p>在你的應用程式中的每個 state：</p>\n<ul>\n<li>指出每個根據 state 來 render 某些東西的 component。</li>\n<li>找出一個共同擁有者 component（在層級中單一一個需要 state 的、在所有的 component 之上的 component）。</li>\n<li>應該擁有 state 的會是共同擁有者 component 或另一個更高層級的 component。</li>\n<li>如果你找不出一個應該擁有 state 的 component 的話，那就建立一個新的 component 來保持 state，並把它加到層級中共同擁有者 component 之上的某處。</li>\n</ul>\n<p>讓我們來討論一下我們應用程式的這個策略：</p>\n<ul>\n<li><code class=\"gatsby-code-text\">ProductTable</code> 需要根據 state 來篩選產品列表，而 <code class=\"gatsby-code-text\">SearchBar</code> 需要展示搜尋關鍵字和 checkbox 的 state。</li>\n<li>這兩個 component 的共同擁有者 component 是 <code class=\"gatsby-code-text\">FilterableProductTable</code>。</li>\n<li>概念上來說，篩選過的文字和復選框的值存在於 <code class=\"gatsby-code-text\">FilterableProductTable</code> 中是合理的。</li>\n</ul>\n<p>很好，所以我們現在已經決定我們的 state 會存在於 <code class=\"gatsby-code-text\">FilterableProductTable</code> 之中。首先，把這個實例的 property <code class=\"gatsby-code-text\">this.state = {filterText: '', inStockOnly: false}</code> 加到 <code class=\"gatsby-code-text\">FilterableProductTable</code> 的 <code class=\"gatsby-code-text\">constructor</code> 裡面以反映你的應用程式的初始 state。接著，把 <code class=\"gatsby-code-text\">filterText</code> 和 <code class=\"gatsby-code-text\">inStockOnly</code> 作為 prop 傳給 <code class=\"gatsby-code-text\">ProductTable</code> 和 <code class=\"gatsby-code-text\">SearchBar</code>。最後，用這些 prop 來篩選 <code class=\"gatsby-code-text\">ProductTable</code> 中的列，並設定 <code class=\"gatsby-code-text\">SearchBar</code> 中的表格欄的值。</p>\n<p>你可以開始看到你的應用程式會如何運作：將 <code class=\"gatsby-code-text\">filterText</code> 設定為 <code class=\"gatsby-code-text\">「ball」</code> 並更新你的程式。你會看到資料表被正確地更新了。</p>\n<h2 id=\"step-5-add-inverse-data-flow\"><a href=\"#step-5-add-inverse-data-flow\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>第五步：加入相反的資料流 </h2>\n<p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"LzWZvb\" data-default-tab=\"js,result\" data-user=\"rohan10\" data-embed-version=\"2\" data-pen-title=\"Thinking In React: Step 5\" class=\"codepen\"> 在 <a href=\"http://codepen.io\">CodePen</a> 中看<a href=\"https://codepen.io/gaearon/pen/LzWZvb\">用 React 思考：第五步</a>。</p>\n<p>到目前為止，我們已經建立了一個作為含有從層級由上往下傳 props 和 state 的、且可以正確 render 的 function 的應用程式。現在是時候支援另一種資料流的方向了：在層級深處的表格 component 需要更新 <code class=\"gatsby-code-text\">FilterableProductTable</code> 的 state。</p>\n<p>React 將這種資料流明確表示出來，以便讓你能更容易理解你的程式如何運作，但是這的確比傳統的雙向資料綁定需要打多一點字。</p>\n<p>如果你試著在範例目前的版本中印出或勾選 checkbox，你會看到 React 無視你的輸入。這是刻意的，因為我們把 <code class=\"gatsby-code-text\">input</code> 的 <code class=\"gatsby-code-text\">value</code> prop 設定為永遠和從 <code class=\"gatsby-code-text\">FilterableProductTable</code> 傳下來的 <code class=\"gatsby-code-text\">state</code> ㄧ樣。</p>\n<p>讓我們思考一下我們想要做些什麼。我們想確保當使用者改變這個表格時，我們會更新 state 以反映使用者的輸入。既然 component 只應該更新它自己本身的 state， <code class=\"gatsby-code-text\">FilterableProductTable</code> 將會把 callback 傳給 <code class=\"gatsby-code-text\">SearchBar</code>，而它們則會在 state 該被更新的時候被觸發。我們可以在輸入上使用 <code class=\"gatsby-code-text\">onChange</code> 這個 event 來\n接收通知。被 <code class=\"gatsby-code-text\">FilterableProductTable</code> 傳下來的 callback 則會呼叫 <code class=\"gatsby-code-text\">setState()</code>，之後應用程式就會被更新。</p>\n<h2 id=\"and-thats-it\"><a href=\"#and-thats-it\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>完成 </h2>\n<p>希望這幫助你理解如何用 React 建立 component 和應用程式。雖然這可能需要你比你習慣的多打一些程式碼，請記得閱讀程式碼比起寫程式碼更常發生，而閱讀這種模組化、清晰明確的程式碼是非常容易的。當你開始建立大型的 component 函式庫時，你會很感激有這樣的明確性和模組性，而當你開始重複使用程式碼時，你的程式的行數會開始減少。:)</p>","frontmatter":{"title":"用 React 思考","next":null,"prev":"composition-vs-inheritance.html"},"fields":{"path":"content/docs/thinking-in-react.md","slug":"docs/thinking-in-react.html"}}},"pageContext":{"slug":"docs/thinking-in-react.html"}},"staticQueryHashes":[]}