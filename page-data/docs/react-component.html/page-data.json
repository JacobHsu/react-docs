{"componentChunkName":"component---src-templates-docs-js","path":"/docs/react-component.html","result":{"data":{"markdownRemark":{"html":"<p>本章節包含了 React component class 的詳細 API 參考。我們假設你對 React 的基本概念已十分熟悉，例如 <a href=\"/docs/components-and-props.html\">Component 和 Prop</a> 以及 <a href=\"/docs/state-and-lifecycle.html\">State 和 生命週期</a>。如果你對這些概念還不清楚，請先閱讀相關文件。</p>\n<h2 id=\"overview\"><a href=\"#overview\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>概觀 </h2>\n<p>在 React 中，你可以將 component 定義成 class 或 function。目前，被定義為 class 的 component 提供了更多功能，我們將會在本章節中逐一介紹。要定義一個 React component class，你需要繼承（extend）<code class=\"gatsby-code-text\">React.Component</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Welcome</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello, </span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 <code class=\"gatsby-code-text\">React.Component</code> 的 subclass 中唯一一個你<em>必須</em>定義的方法是 <a href=\"#render\"><code class=\"gatsby-code-text\">render()</code></a>。本章節中所有其他的方法都並非絕對必要。</p>\n<p><strong>我們強烈建議你不要建立自己的 base component class。</strong> 在 React component 中，<a href=\"/docs/composition-vs-inheritance.html\">程式的重複使用性主要是透過組合而非繼承來完成的</a>。</p>\n<blockquote>\n<p>注意：</p>\n<p>React 並不會強迫你使用 ES6 class 語法。如果你想避免它的話，你可以使用 <code class=\"gatsby-code-text\">create-react-class</code> 或一個類似的自訂抽象。想了解更多詳情，請參考<a href=\"/docs/react-without-es6.html\">如何在 React 中不使用 ES6</a>一文。</p>\n</blockquote>\n<h3 id=\"the-component-lifecycle\"><a href=\"#the-component-lifecycle\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Component 生命週期 </h3>\n<p>每一個 component 都有數個 「生命週期方法」，你可以 <a href=\"https://en.wikipedia.org/wiki/Method_overriding\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">override</a> 這些方法，以便在開發過程中某些特定的時刻執行某些程式。<strong>你可以使用<a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">這個生命週期表</a>作為速查表。</strong> 以下，常用的生命週期方法將會以粗體表達。其餘的生命週期方法則相對較少。</p>\n<h4 id=\"mounting\"><a href=\"#mounting\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mounting </h4>\n<p>當一個 component 的 instance 被建立且加入 DOM 中時，其生命週期將會依照下列的順序呼叫這些方法：</p>\n<ul>\n<li><a href=\"#constructor\"><strong><code class=\"gatsby-code-text\">constructor()</code></strong></a></li>\n<li><a href=\"#static-getderivedstatefromprops\"><code class=\"gatsby-code-text\">static getDerivedStateFromProps()</code></a></li>\n<li><a href=\"#render\"><strong><code class=\"gatsby-code-text\">render()</code></strong></a></li>\n<li><a href=\"#componentdidmount\"><strong><code class=\"gatsby-code-text\">componentDidMount()</code></strong></a></li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<p>下列方法已過時，你在寫新程式應<a href=\"/blog/2018/03/27/update-on-async-rendering.html\">避免使用</a>：</p>\n<ul>\n<li><a href=\"#unsafe_componentwillmount\"><code class=\"gatsby-code-text\">UNSAFE_componentWillMount()</code></a></li>\n</ul>\n</blockquote>\n<h4 id=\"updating\"><a href=\"#updating\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>更新 </h4>\n<p>當 prop 或 state 有變化時，就會產生更新。當一個 component 被重新 render 時，其生命週期將會依照下列的順序呼叫這些方法：</p>\n<ul>\n<li><a href=\"#static-getderivedstatefromprops\"><code class=\"gatsby-code-text\">static getDerivedStateFromProps()</code></a></li>\n<li><a href=\"#shouldcomponentupdate\"><code class=\"gatsby-code-text\">shouldComponentUpdate()</code></a></li>\n<li><a href=\"#render\"><strong><code class=\"gatsby-code-text\">render()</code></strong></a></li>\n<li><a href=\"#getsnapshotbeforeupdate\"><code class=\"gatsby-code-text\">getSnapshotBeforeUpdate()</code></a></li>\n<li><a href=\"#componentdidupdate\"><strong><code class=\"gatsby-code-text\">componentDidUpdate()</code></strong></a></li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<p>下列方法已過時，你在寫新程式應<a href=\"/blog/2018/03/27/update-on-async-rendering.html\">避免使用</a>：</p>\n<ul>\n<li><a href=\"#unsafe_componentwillupdate\"><code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code></a></li>\n<li><a href=\"#unsafe_componentwillreceiveprops\"><code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps()</code></a></li>\n</ul>\n</blockquote>\n<h4 id=\"unmounting\"><a href=\"#unmounting\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmounting </h4>\n<p>當一個 component 被從 DOM 中移除時，這個方法將會被呼叫：</p>\n<ul>\n<li><a href=\"#componentwillunmount\"><strong><code class=\"gatsby-code-text\">componentWillUnmount()</code></strong></a></li>\n</ul>\n<h4 id=\"error-handling\"><a href=\"#error-handling\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>錯誤處理 </h4>\n<p>當一個 component 在 render 的過程、生命週期、或在某個 child component 的 constructor 中發生錯誤時，這些方法會被呼叫：</p>\n<ul>\n<li><a href=\"#static-getderivedstatefromerror\"><code class=\"gatsby-code-text\">static getDerivedStateFromError()</code></a></li>\n<li><a href=\"#componentdidcatch\"><code class=\"gatsby-code-text\">componentDidCatch()</code></a></li>\n</ul>\n<h3 id=\"other-apis\"><a href=\"#other-apis\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>其他 APIs </h3>\n<p>每個 component 也提供了其他 API：</p>\n<ul>\n<li><a href=\"#setstate\"><code class=\"gatsby-code-text\">setState()</code></a></li>\n<li><a href=\"#forceupdate\"><code class=\"gatsby-code-text\">forceUpdate()</code></a></li>\n</ul>\n<h3 id=\"class-properties\"><a href=\"#class-properties\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class 屬性 </h3>\n<ul>\n<li><a href=\"#defaultprops\"><code class=\"gatsby-code-text\">defaultProps</code></a></li>\n<li><a href=\"#displayname\"><code class=\"gatsby-code-text\">displayName</code></a></li>\n</ul>\n<h3 id=\"instance-properties\"><a href=\"#instance-properties\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Instance 屬性 </h3>\n<ul>\n<li><a href=\"#props\"><code class=\"gatsby-code-text\">props</code></a></li>\n<li><a href=\"#state\"><code class=\"gatsby-code-text\">state</code></a></li>\n</ul>\n<hr>\n<h2 id=\"reference\"><a href=\"#reference\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>參考指南 </h2>\n<h3 id=\"commonly-used-lifecycle-methods\"><a href=\"#commonly-used-lifecycle-methods\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>常用的生命周期方法 </h3>\n<p>此段落將會介紹你在建立 React component 時最可能會使用到的幾種方法。<strong>想更深入了解生命週期方法，請參考<a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">生命週期表</a>。</strong></p>\n<h3 id=\"render\"><a href=\"#render\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">render()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"gatsby-code-text\">render()</code> 是 class component 中唯一必要的方法。</p>\n<p>當 render 被呼叫時，它將會檢視 <code class=\"gatsby-code-text\">this.props</code> 和 <code class=\"gatsby-code-text\">this.state</code> 中的變化，並回傳以下類別之一：</p>\n<ul>\n<li><strong>React element。</strong> 通常是透過 <a href=\"/docs/introducing-jsx.html\">JSX</a> 建立的。例如，<code class=\"gatsby-code-text\">&lt;div /></code>和<code class=\"gatsby-code-text\">&lt;MyComponent /></code>這兩個 React element 會告訴 React 要 render 一個 DOM node 和一個使用者定義的 component。</li>\n<li><strong>Array 和 fragment。</strong> 它們會從 render 中回傳數個 element。細節請參考 <a href=\"/docs/fragments.html\">fragment</a>。</li>\n<li><strong>Portal</strong>。它們讓你將 children render 到不同的 DOM subtree 中。細節請參考 <a href=\"/docs/portals.html\">portal</a>。</li>\n<li><strong>String 和 number。</strong> 這些在 DOM 中將會被 render 為文字 node。</li>\n<li><strong>Boolean 或 <code class=\"gatsby-code-text\">null</code>。</strong> 什麼都不 render。（此類型主要是支援 <code class=\"gatsby-code-text\">回傳 test &amp;&amp; &lt;Child /></code> 的模式，這裡的 <code class=\"gatsby-code-text\">test</code> 是一個 boolean 值）。</li>\n</ul>\n<p><code class=\"gatsby-code-text\">render()</code> function 應該是 pure 的，這表示：它並不會改變 component 的 state，它在每次呼叫時都會回傳同樣的結果，它並不會直接和瀏覽器有所互動。</p>\n<p>如果你需要和瀏覽器互動，請在 <code class=\"gatsby-code-text\">componentDidMount()</code> 或其他的生命週期方法內執行你的程式。將 <code class=\"gatsby-code-text\">render()</code> 維持在 pure 的狀態有助於你對 component 的理解。</p>\n<blockquote>\n<p>注意：</p>\n<p>若 <a href=\"#shouldcomponentupdate\"><code class=\"gatsby-code-text\">shouldComponentUpdate()</code></a> 回傳的值為 <code class=\"gatsby-code-text\">false</code> 的話，<code class=\"gatsby-code-text\">render()</code>將不會被呼叫。</p>\n</blockquote>\n<hr>\n<h3 id=\"constructor\"><a href=\"#constructor\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">constructor()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>如果你沒有初始化 state 也不綁定方法的話，你的 React component 就不需要 constructor。</strong></p>\n<p>一個 React component 的 constructor 會在其被 mount 之前被呼叫。當你為一個 <code class=\"gatsby-code-text\">React.Component</code> subclass 建立 constructor 時，你應該在其他任何宣告之前呼叫 <code class=\"gatsby-code-text\">super(props)</code>。否則，<code class=\"gatsby-code-text\">this.props</code> 在 constructor 中的值會出現 undefined 的 bug。</p>\n<p>通常在 React 中 constructor 只會有兩種用途：</p>\n<ul>\n<li>透過指定一個 <code class=\"gatsby-code-text\">this.state</code> 物件來初始化<a href=\"/docs/state-and-lifecycle.html\">內部 state</a>。</li>\n<li>為 <a href=\"/docs/handling-events.html\">event handler</a> 方法綁定 instance。</li>\n</ul>\n<p>請<strong>不要在 <code class=\"gatsby-code-text\">constructor()</code> 中呼叫 <code class=\"gatsby-code-text\">setState()</code></strong>。如果你的 component 需要使用內部 state，請在 constructor 中<strong>將其最初的 state 指定為 <code class=\"gatsby-code-text\">this.state</code></strong>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 不要在這裡呼叫 this.setState()！</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> counter<span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleClick</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Constructor 是唯一一個你應該直接指定 <code class=\"gatsby-code-text\">this.state</code> 的地方。在所有其他的方法中，你則需要使用 <code class=\"gatsby-code-text\">this.setState()</code>。</p>\n<p>請避免在 constructor 中產生任何 side effect 或 subscription。如果你需要它們的話，請使用 <code class=\"gatsby-code-text\">componentDidMount()</code>。</p>\n<blockquote>\n<p>注意：</p>\n<p><strong>請避免複製 prop 到 state 之中！這是一個很常見的錯誤：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token comment\">// 請不要這樣做！</span>\n <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> color<span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>color <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這樣做的問題是：一來這毫無必要（你可以直接用 <code class=\"gatsby-code-text\">this.props.color</code>），二來這會產生 bug（任何改變對 <code class=\"gatsby-code-text\">color</code> prop 所產生的更新都不會出現在 state 中）。</p>\n<p><strong>請在只有在你刻意要忽略 prop 更新的情況下才使用這個模式。</strong> 在這種情況下，比較合理的做法是將 prop 重新命名為 <code class=\"gatsby-code-text\">initialColor</code> 或 <code class=\"gatsby-code-text\">defaultColor</code>。如此一來，你可以在必要的情況下透過<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\">修改一個 component 的 <code class=\"gatsby-code-text\">key</code></a> 來強迫它「重置」其初始的 state。</p>\n<p>若想知道如何處理 state 依賴 prop 的情況，請參考我們 <a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html\">關於避免 derived state 的部落格文章</a>。</p>\n</blockquote>\n<hr>\n<h3 id=\"componentdidmount\"><a href=\"#componentdidmount\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">componentDidMount()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>在一個 component 被 mount（加入 DOM tree 中）後，<code class=\"gatsby-code-text\">componentDidMount()</code> 會馬上被呼叫。需要 DOM node 的初始化應該寫在這個方法裡面。如果你需要從遠端終端點（remote endpoint）請求資料的話, 此處非常適合進行實例化網路請求（network request）。</p>\n<p>這個方法適合設立任何 subscription。設立完 subscription 後，別忘了在 <code class=\"gatsby-code-text\">componentWillUnmount()</code> 內取消 subscription。</p>\n<p>你<strong>可以馬上在 <code class=\"gatsby-code-text\">componentDidMount()</code> 內呼叫 <code class=\"gatsby-code-text\">setState()</code>。</strong>這會觸發一次額外的 render，但這會在瀏覽器更新螢幕之前發生。在這個情況下，即使 <code class=\"gatsby-code-text\">render()</code> 被呼叫兩次，這確保使用者不會看見這兩次 render 中過渡時期的 state。請謹慎使用這個模式，因為這經常會導致效能問題。在大多數情況下，你應該能夠在  <code class=\"gatsby-code-text\">constructor()</code> 內指定初始 state 的值。不過，在某些情況下，像是在使用 modal 和 tooltip 的時候，你所 render 的 component 若是依賴某個 DOM node 的大小或位置時，這種模式有時候可能是有必要的。</p>\n<hr>\n<h3 id=\"componentdidupdate\"><a href=\"#componentdidupdate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">componentDidUpdate()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">,</span> snapshot<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"gatsby-code-text\">componentDidUpdate()</code> 會在更新後馬上被呼叫。這個方法並不會在初次 render 時被呼叫。</p>\n<p>在 component 更新之後，可以在此處對 DOM 進行運作。此處也適合做網路請求，如果你有比較目前的 prop 和之前的 prop 的話（如果 prop 沒有改變的話，網路請求可能並非必要）。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 常見用法（別忘了比較 prop）：</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>userID <span class=\"token operator\">!==</span> prevProps<span class=\"token punctuation\">.</span>userID<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>userID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>你<strong>可以馬上在 <code class=\"gatsby-code-text\">componentDidUpdate()</code> 內呼叫 <code class=\"gatsby-code-text\">setState()</code></strong>，但注意這必須要被包圍在一個類似上述範例的條件語句內，否則你會進入一個無限迴圈。這也會導致額外的重新 render。雖然使用者看不見，但這可能會影響 component 的效能。如果你想試著將某些 state 複製到由上往下傳的 prop 的話，請考慮直接使用 prop。請參考<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html\">為何複製 prop 到 state 中會產生 bug</a>。</p>\n<p>如果你的 component 裡面有 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate()</code> 這個很少見的生命週期方法，其回傳的值將會被當作第三個「snapshot」參數傳給 <code class=\"gatsby-code-text\">componentDidUpdate()</code>。否則這個參數會是 undefined。</p>\n<blockquote>\n<p>注意：</p>\n<p>如果 <a href=\"#shouldcomponentupdate\"><code class=\"gatsby-code-text\">shouldComponentUpdate()</code></a> 回傳的值為 false 的話，<code class=\"gatsby-code-text\">componentDidUpdate()</code> 將不會被呼叫。</p>\n</blockquote>\n<hr>\n<h3 id=\"componentwillunmount\"><a href=\"#componentwillunmount\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">componentWillUnmount()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"gatsby-code-text\">componentWillUnmount()</code> 會在ㄧ個 component 被 unmount 和 destroy 後馬上被呼叫。你可以在這個方法內進行任何清理，像是取消計時器和網路請求或是移除任何在 <code class=\"gatsby-code-text\">componentDidMount()</code> 內建立的  subscription。</p>\n<p>你<strong>不應該在 <code class=\"gatsby-code-text\">componentWillUnmount()</code> 內呼叫 <code class=\"gatsby-code-text\">setState()</code></strong>，因為這個 component 永遠不會再重新 render。當一個 component instance 被 unmount 後，它就永遠不會再被 mount。</p>\n<hr>\n<h3 id=\"rarely-used-lifecycle-methods\"><a href=\"#rarely-used-lifecycle-methods\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>不常使用的生命週期方法 </h3>\n<p>這個章節內介紹的方法是在那些不常見的情況中使用的。它們有時很方便，但是你大多數的 component 大概不會需要使用它們。<strong>你可以在這個<a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">生命週期表</a>上方點選「顯示不常使用的生命週期方法」，並看到以下所介紹的方法。</strong></p>\n<h3 id=\"shouldcomponentupdate\"><a href=\"#shouldcomponentupdate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">shouldComponentUpdate()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span></code></pre></div>\n<p>你可以使用 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 來讓 React 知道一個 component 的 output 並不會被目前在 state 或 prop 內的改變所影響。React 的預設行為是每當 state 有所改變時就重新 render。在絕大多數的情況下，你應該依賴這個預設行為。</p>\n<p><code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 會在新的 prop 或 state 被接收之後並在該 component 被 render 之前被呼叫。其預設值是 <code class=\"gatsby-code-text\">true</code>。這個方法並不會 component 初次 render 時或使用 <code class=\"gatsby-code-text\">forceUpdate()</code> 時被呼叫。</p>\n<p>這個方法的存在著要是為了 <strong><a href=\"/docs/optimizing-performance.html\">效能最佳化</a></strong>。請不要依賴這個方法來「避免」 render，因為這很有可能會導致 bug。<strong>請考慮使用 React 內建的 <a href=\"/docs/react-api.html#reactpurecomponent\"><code class=\"gatsby-code-text\">PureComponent</code></a></strong> 並避免手寫 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code>。<code class=\"gatsby-code-text\">PureComponent</code> 會為 prop 和 state 做一個淺層比較（shallow comparison）並減低你錯過必要更新的機會。</p>\n<p>如果你很確定你想要手寫這個方法的話，你可以將 <code class=\"gatsby-code-text\">this.props</code> 和 <code class=\"gatsby-code-text\">nextProps</code> 以及 <code class=\"gatsby-code-text\">this.state</code> 和 <code class=\"gatsby-code-text\">nextState</code> 做比較並回傳 <code class=\"gatsby-code-text\">false</code> 以告知 React 這次的更新可以被略過。請注意，回傳 <code class=\"gatsby-code-text\">false</code> 並不會避免 child component 在<em>它們的</em> state 改變時重新 render。</p>\n<p>我們並不建議你做深度比較（deep equality check）或在 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 內使用 <code class=\"gatsby-code-text\">JSON.stringify()</code>。它們效率不佳且會造成效能問題。</p>\n<p>目前，如果 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 回傳 <code class=\"gatsby-code-text\">false</code> 的話，<a href=\"#unsafe_componentwillupdate\"><code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code></a>、<a href=\"#render\"><code class=\"gatsby-code-text\">render()</code></a> 和 <a href=\"#componentdidupdate\"><code class=\"gatsby-code-text\">componentDidUpdate()</code></a> 都不會被呼叫。在未來，React 可能會把 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 當作一個提示而非一個嚴格指令，而回傳 <code class=\"gatsby-code-text\">false</code> 可能還是會造成 component 重新 render。</p>\n<hr>\n<h3 id=\"static-getderivedstatefromprops\"><a href=\"#static-getderivedstatefromprops\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">static getDerivedStateFromProps()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 會在一個 component 被 render 前被呼叫，不管是在首次 mount 時或後續的更新時。它應該回傳一個 object 以更新 state，或回傳 <code class=\"gatsby-code-text\">null</code> 以表示不需要更新任何 state。</p>\n<p>這個方法是為了某些<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state\">很少見的例子</a>而存在的，像是有時 state 會依賴 prop 在一段時間過後所產生的改變。例如，也許建立一個 <code class=\"gatsby-code-text\">&lt;Transition></code> component 是很方便的，我們可以用它來比較其之前與之後的 children，並決定我們要 animate in and out 哪一個 child。</p>\n<p>繼承 state 會導致冗長的程式碼並使你的 component 很難理解。<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html\">請確認你知道這些較為簡單的替代方案</a>。</p>\n<ul>\n<li>如果你需要在某個 prop 改變時產生相對應的<strong>side effect</strong>（例如，資料提取或使用動畫），請使用 <a href=\"#componentdidupdate\"><code class=\"gatsby-code-text\">componentDidUpdate</code></a>。</li>\n<li>如果你想要 <strong>在某個 prop 改變時重新計算某些資料</strong>，<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\">請使用 memoization helper</a>。</li>\n<li>如果你想要 <strong>在某個 prop 改變時「重置」某個 state</strong>，請考慮建立一個<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component\">完全被控制</a> 的 component 或<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\">帶有 <code class=\"gatsby-code-text\">key</code> 的完全不可被控制</a> component。</li>\n</ul>\n<p>這個方法無法觸及一個 component 的 instance。如果你想要這麼做的話，你可以把一個 component 的 prop 和 state 提取出來變成 pure function，並寫在該 class definition 之外，並透過這樣的方式在 <code class=\"gatsby-code-text\">getDerivedStateFromProps()</code> 和其他 class 方法之間重複使用某些程式碼。</p>\n<p>請注意這個方法在<em>每一次</em> render 時都會被觸發，不論原因為何。這和 <code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps</code> 有所不同，這個方法只有在 parent 導致重新 render 時被觸發，而非在本地的 <code class=\"gatsby-code-text\">setState</code> 導致重新 render 時被觸發。</p>\n<hr>\n<h3 id=\"getsnapshotbeforeupdate\"><a href=\"#getsnapshotbeforeupdate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">getSnapshotBeforeUpdate()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">getSnapshotBeforeUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"gatsby-code-text\">getSnapshotBeforeUpdate()</code> 在提交最新 render 的 output 之前立即被調用。它讓你在 DOM 改變之前先從其中抓取一些資訊（例如滾動軸的位置）。這個生命週期方法回傳的任何值會被當作一個參數傳遞給 <code class=\"gatsby-code-text\">componentDidUpdate()</code>。</p>\n<p>這個方法並不常見，但它可能會在像是對話串這類需要以某種特殊方始處理滾動軸位置的 UI 中出現。</p>\n<p>一個 snapshot 的值（或 <code class=\"gatsby-code-text\">null</code>）應該被回傳。</p>\n<p>例如：</p>\n<p><div class=\"gatsby-highlight\">\n        <pre class=\"gatsby-code-jsx\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">ScrollingList</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>listRef <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">getSnapshotBeforeUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps<span class=\"token punctuation\">,</span> prevState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Are we adding new items to the list?</span>\n    <span class=\"token comment\">// Capture the scroll position so we can adjust scroll later.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>listRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">.</span>scrollHeight <span class=\"token operator\">-</span> list<span class=\"token punctuation\">.</span>scrollTop<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">,</span> snapshot</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// If we have a snapshot value, we've just added new items.</span>\n    <span class=\"token comment\">// Adjust scroll so these new items don't push the old ones out of view.</span>\n    <span class=\"token comment\">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>snapshot <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>listRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n      list<span class=\"token punctuation\">.</span>scrollTop <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span>scrollHeight <span class=\"token operator\">-</span> snapshot<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>listRef<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token comment\">/* ...contents... */</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n        </div></p>\n<p>在上面這個例子中，讀取 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code> 內的 <code class=\"gatsby-code-text\">scrollHeight</code> property 是很重要的，因為「render」階段的生命週期方法（如 <code class=\"gatsby-code-text\">render</code>）和「commit」階段的生命週期方法（像是 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code> 和 <code class=\"gatsby-code-text\">componentDidUpdate</code>）兩者之間可能會有一些延遲。</p>\n<hr>\n<h3 id=\"error-boundaries\"><a href=\"#error-boundaries\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>錯誤邊界 </h3>\n<p><a href=\"/docs/error-boundaries.html\">錯誤邊界</a> 是用於截取 child component tree 中 JavaScript 錯誤、記錄錯誤、並顯示一個 fallback UI 而非故障的 component tree 的一群 React component。錯誤邊界會在 render 期間、生命週期方法、以及其下整個 tree 群組所有的 constructor 內截取錯誤。</p>\n<p>一個 class component 會變成錯誤邊界，如果其定義了 <code class=\"gatsby-code-text\">static getDerivedStateFromError()</code> 和 <code class=\"gatsby-code-text\">componentDidCatch()</code> 兩種或其中之一的生命週期方法。 從這些生命週期方法中更新 state 讓你截取在其下的 tree 內未被處理的 JavaScript 錯誤，並顯示一個 fallback UI。</p>\n<p>請只在從意料之外的異常中使用錯誤邊界。<strong>請不要用它來控制流程。</strong></p>\n<p>想了解更多，請參考 <a href=\"/blog/2017/07/26/error-handling-in-react-16.html\"><em>React 16 中的錯誤邊界</em></a>一文。</p>\n<blockquote>\n<p>注意：</p>\n<p>錯誤邊界只會截取在 tree 中、自身<strong>以下</strong>的 component 中的錯誤。錯誤邊界無法截取自身內的錯誤。</p>\n</blockquote>\n<h3 id=\"static-getderivedstatefromerror\"><a href=\"#static-getderivedstatefromerror\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">static getDerivedStateFromError()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span></code></pre></div>\n<p>這個生命週期方法會在某個錯誤被一個 descendant component 拋出後被呼叫。\n它會接收該錯誤為其參數並回傳一個值以更新 state。</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ErrorBoundary</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">// 更新 state，如此下次 render 時 React 才能顯示 fallback UI</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span></span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>hasError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token comment\">// 你可以 render 任何自訂的 fallback UI</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Something went wrong.</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token punctuation\">}</span></span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>注意：</p>\n<p><code class=\"gatsby-code-text\">getDerivedStateFromError()</code> 會在「render」期間被呼叫，所以 side effect 是不被允許的。\n如果你想要使用 side effect 的話，請使用 <code class=\"gatsby-code-text\">componentDidCatch()</code>。</p>\n</blockquote>\n<hr>\n<h3 id=\"componentdidcatch\"><a href=\"#componentdidcatch\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">componentDidCatch()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">componentDidCatch</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span></code></pre></div>\n<p>這個生命週期方法會在某個錯誤被一個 descendant component 拋出後被呼叫。\n它接受兩個參數：</p>\n<ol>\n<li><code class=\"gatsby-code-text\">error</code> - 被拋出的錯誤。</li>\n<li><code class=\"gatsby-code-text\">info</code> - 一個有 <code class=\"gatsby-code-text\">componentStack</code> key 的 object，這個 key 包含有<a href=\"/docs/error-boundaries.html#component-stack-traces\">那一個 component 拋出錯誤的資訊</a>。</li>\n</ol>\n<p><code class=\"gatsby-code-text\">componentDidCatch()</code> 會在「commit」期間被呼叫，所以 side effect 是被允許的。\n這個方法應該被用來做類似記錄錯誤這類的事情：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ErrorBoundary</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 更新 state，如此下次 render 時 React 才能顯示 fallback UI</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">componentDidCatch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">error<span class=\"token punctuation\">,</span> info</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">// ComponentStack 的範例：</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">//   in ComponentThatThrows (created by App)</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">//   in ErrorBoundary (created by App)</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">//   in div (created by App)</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">//   in App</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">logComponentStackToMyService</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">.</span>componentStack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span></span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>hasError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 你可以 render 任何自訂的 fallback UI</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Something went wrong.</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React 在 production 和 development 在處理 <code class=\"gatsby-code-text\">componentDidCatch()</code> 錯誤的方式不同。</p>\n<p>在 development 時，錯誤將會冒泡到 <code class=\"gatsby-code-text\">window</code>，意思是任何的 <code class=\"gatsby-code-text\">window.onerror</code> 或 <code class=\"gatsby-code-text\">window.addEventListener('error', callback)</code> 將攔截透過 <code class=\"gatsby-code-text\">componentDidCatch</code> 所捕捉到的錯誤。</p>\n<p>反之，在 production 時不會冒泡，意思是任何 ancestor 錯誤處理將只會接收未由 <code class=\"gatsby-code-text\">componentDidCatch()</code> 明確捕捉的錯誤。</p>\n<blockquote>\n<p>注意：</p>\n</blockquote>\n<blockquote>\n<p>在有錯誤的情況下，你可以透過呼叫 <code class=\"gatsby-code-text\">setState</code> 來 render 一個含有 <code class=\"gatsby-code-text\">componentDidCatch()</code> 的 fallback UI，但這個方法會在未來的版本中會被棄用。\n請使用 <code class=\"gatsby-code-text\">static getDerivedStateFromError()</code> 來處理 fallback render。</p>\n</blockquote>\n<hr>\n<h3 id=\"legacy-lifecycle-methods\"><a href=\"#legacy-lifecycle-methods\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>過時的生命週期方法 </h3>\n<p>以下介紹的幾個生命週期方法是「過時」的。它們仍然能運作，但我們並不建議你在新的程式碼內使用這些方法。你可以<a href=\"/blog/2018/03/27/update-on-async-rendering.html\">在這篇文章中</a>了解如何從過時的方法 migrate 到我們建議的方法。</p>\n<h3 id=\"unsafe_componentwillmount\"><a href=\"#unsafe_componentwillmount\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">UNSAFE_componentWillMount()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">UNSAFE_componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>注意：</p>\n<p>這個生命週期方法先前的命名是 <code class=\"gatsby-code-text\">componentWillMount</code>。這個命名直到第 17 版仍然能繼續運作。請使用<a href=\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">重新命名不安全的生命週期方法</code> codemod</a> 來自動更新你的 component。</p>\n</blockquote>\n<p><code class=\"gatsby-code-text\">UNSAFE_componentWillMount()</code> 會在 mounting 發生前被呼叫。它會在 <code class=\"gatsby-code-text\">render()</code> 前被呼叫，因此在這個方法內同步呼叫 <code class=\"gatsby-code-text\">setState()</code> 並不會觸發額外的 render。不過，一般情況來說，我們建議你使用 <code class=\"gatsby-code-text\">constructor()</code> 來初始化 state。</p>\n<p>請避免在這個方法中帶入任何的 side effect 或 subscription。如果你需要那樣做的話，請使用 <code class=\"gatsby-code-text\">componentDidMount()</code>。</p>\n<p>這是唯一一個在伺服器端 render 時被呼叫的生命週期方法。</p>\n<hr>\n<h3 id=\"unsafe_componentwillreceiveprops\"><a href=\"#unsafe_componentwillreceiveprops\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">UNSAFE_componentWillReceiveProps</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>注意：</p>\n<p>這個生命週期方法先前的命名是 <code class=\"gatsby-code-text\">componentWillReceiveProps</code>。這個命名直到第 17 版仍然能繼續運作。請使用<a href=\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">重新命名不安全的生命週期方法</code> codemod</a> 來自動更新你的 component。</p>\n</blockquote>\n<blockquote>\n<p>注意：</p>\n<p>這個生命週期方法常常會導致 bug 和程式碼的不一致。</p>\n<ul>\n<li>如果你需要在某個 prop 改變時 <strong>執行一個相對應的 side effect</strong>（例如資料提取或使用動畫），請使用<a href=\"#componentdidupdate\"><code class=\"gatsby-code-text\">componentDidUpdate</code></a> 這個生命週期方法。</li>\n<li>如果你想要 <strong>只在某個 prop 改變時重新計算某些資料</strong>，<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\">請使用 memoization helper</a>。</li>\n<li>如果你想要 <strong>在某個 prop 改變時「重置」某個 state</strong>，請考慮建立一個<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component\">完全被控制</a> 的 component 或<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\">帶有 <code class=\"gatsby-code-text\">key</code> 的完全被控制</a> component。</li>\n</ul>\n<p>針對以上這些使用情境，請<a href=\"/blog/2018/06/07/you-probably-dont-need-derived-state.html\">遵照這篇文章內推薦的方法來處理繼承的 state</a>。</p>\n</blockquote>\n<p><code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps()</code> 會在一個被 mount 的 component 接收新的 prop 前被呼叫。如果你需要在某個 prop 改變時更新 state 的話（例如，重置 state），你可以在這個生命週期方法裡面比較 <code class=\"gatsby-code-text\">this.props</code> 和<code class=\"gatsby-code-text\">nextProps</code>，並使用 <code class=\"gatsby-code-text\">this.setState()</code> 進行 state 的轉移。</p>\n<p>請注意如果一個 parent component 導致你的 component 重新 render 的話，即使 prop 沒有改變，這個方法仍然會被呼叫。如果你不想要有這些改變的話，請確認你有比較目前和之後的 prop 的值。</p>\n<p>React 並不會在初次 <a href=\"#mounting\">mounting</a> 時使用初始化的 props 來呼叫 <code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps()</code>。它只會在 component 某些 prop 可能會更新時呼叫這個方法。一般來說，呼叫 <code class=\"gatsby-code-text\">this.setState()</code> 並不會觸發 <code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps()</code>。</p>\n<hr>\n<h3 id=\"unsafe_componentwillupdate\"><a href=\"#unsafe_componentwillupdate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">UNSAFE_componentWillUpdate</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>注意：</p>\n<p>這個生命週期方法先前的命名是 <code class=\"gatsby-code-text\">componentWillUpdate</code>。這個命名直到第 17 版仍然能繼續運作。請使用<a href=\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">重新命名不安全的生命週期方法</code> codemod</a> 來自動更新你的 component。</p>\n</blockquote>\n<p><code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code> 會在 render 發生之前、當新的 prop 或 state 正在被接收時被呼叫。請將這個方法作為更新發生之前做準備的一個機會。這個方法並不會在初次 render 時被呼叫。</p>\n<p>請注意你不能在這裡呼叫 <code class=\"gatsby-code-text\">this.setState()</code>，你也不應該在這裡進行其他任何在 <code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code> 回傳之前會觸發 React component 更新的行為（例如 dispatch 一個 Redux action）。</p>\n<p>通常，這個方法可以被 <code class=\"gatsby-code-text\">componentDidUpdate()</code> 取代。如果你在這個方法內從 DOM 中讀取資料（例如儲存滾動軸的位置），你可以將那部分的邏輯移到 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate()</code> 裡面。</p>\n<blockquote>\n<p>注意：</p>\n<p>如果 <a href=\"#shouldcomponentupdate\"><code class=\"gatsby-code-text\">shouldComponentUpdate()</code></a> 回傳 false 的話，<code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate()</code> 將不會被呼叫。</p>\n</blockquote>\n<hr>\n<h2 id=\"other-apis-1\"><a href=\"#other-apis-1\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>其他的 API </h2>\n<p>和上述那些由 React 替你呼叫的生命週期方法不同，以下介紹的方法是<em>你</em>可以從你的 component 呼叫的。</p>\n<p>只有兩個方法： <code class=\"gatsby-code-text\">setState()</code> 和 <code class=\"gatsby-code-text\">forceUpdate()</code>。</p>\n<h3 id=\"setstate\"><a href=\"#setstate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">setState()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>updater<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>callback<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"gatsby-code-text\">setState()</code> 會將改變排進一個 queue 中，並告知 React 這個 component 以及它的 children 需要用更新後的 state 重新 render。這是你會在事件處理和伺服器回應用來更新使用者介面最主要的方法。</p>\n<p>請把 <code class=\"gatsby-code-text\">setState()</code> 想成一個<em>請求</em>而非一個馬上對 component 進行更新的指令。為了達到更好的效能，React 也許會延遲這個請求，然後一次更新數個 component。React 並不保證 state 的改變會馬上發生。</p>\n<p><code class=\"gatsby-code-text\">setState()</code> 並不會總是馬上更新 component。它有可能會將更新分批處理更新或延遲到稍後才更新。這使得在呼叫 <code class=\"gatsby-code-text\">setState()</code> 後讀取 <code class=\"gatsby-code-text\">this.state</code> 成為一個潛在的問題。因此請不要這麼做。相反的，請使用 <code class=\"gatsby-code-text\">componentDidUpdate</code> 或一個 <code class=\"gatsby-code-text\">setState</code> callback（<code class=\"gatsby-code-text\">setState(updater, callback)</code>）。不論你使用哪一個，React 都保證它會在更新後被觸發。如果你需要基於先前的 state 來設定 state 的話，請閱讀以下關於 <code class=\"gatsby-code-text\">updater</code> 的參數。</p>\n<p>除非 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 回傳 <code class=\"gatsby-code-text\">false</code>，<code class=\"gatsby-code-text\">setState()</code> 一定會導致重新 render。如果你有使用 mutable object，或者你無法在 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 裡面建立條件式 render 的邏輯的話，只在新的 state 和先前的 state 不同時呼叫 <code class=\"gatsby-code-text\">setState()</code> 將會避免不必要的重新 render。</p>\n<p>這個方法的第一個參數是一個帶有如下的形式的 <code class=\"gatsby-code-text\">updater</code> function：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> props</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> stateChange</code></pre></div>\n<p><code class=\"gatsby-code-text\">state</code> 是當某個改變正在被應用時對 component state 的一個參考。它不應該直接被 mutate。相反的，任何改變都應該用一個基於 <code class=\"gatsby-code-text\">state</code> 和 <code class=\"gatsby-code-text\">props</code> 的 input 所建立的新的 object 來表示。例如，假設我們想要使用 <code class=\"gatsby-code-text\">props.step</code> 來增加 state 中的某個值的話：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> props</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>counter<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>counter <span class=\"token operator\">+</span> props<span class=\"token punctuation\">.</span>step<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>被 updater function 所接受的 <code class=\"gatsby-code-text\">state</code> 和 <code class=\"gatsby-code-text\">props</code> 兩者都保證一定會被更新到最新的狀態。Updater 的 output 會被和 <code class=\"gatsby-code-text\">state</code> 淺層合併。</p>\n<p><code class=\"gatsby-code-text\">setState()</code> 的第二個參數是一個非必要、選擇性的 callback function。它會在 <code class=\"gatsby-code-text\">setState</code> 完成且 component 被重新 render 後被執行。一般來說如果你要使用這樣的邏輯的話，我們比較推薦你使用 <code class=\"gatsby-code-text\">componentDidUpdate()</code>。</p>\n<p>你可以選擇將一個 object（而非 function）作為第一個參數傳給 <code class=\"gatsby-code-text\">setState()</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>stateChange<span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>這會將 <code class=\"gatsby-code-text\">stateChange</code> 淺層合併至新的 state 中。舉個例子，假設你想調整購物車中物品的數量：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>quantity<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>這種形式的 <code class=\"gatsby-code-text\">setState()</code> 也是同步的，而同樣一個週期中的多次呼叫有可能會被結合成一批做處理。例如，假設你想在同一個週期中增加某個物品的數量超過一次的話，這樣做的結果會和以下程式碼相同：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"gatsby-code-javascript\"><code class=\"gatsby-code-javascript\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>\n  previousState<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>quantity<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>quantity <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>quantity<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>quantity <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>在同一個週期中，後續的呼叫會覆蓋之前的呼叫所產生的值，所以物品的數量只會被增加一次。如果下個 state 是根據目前的 state 而決定的話，我們比較建議你用 updater function 來更新 state：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>quantity<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>quantity <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>想了解更多細節，請參考：</p>\n<ul>\n<li><a href=\"/docs/state-and-lifecycle.html\">State 和生命週期指南</a></li>\n<li><a href=\"https://stackoverflow.com/a/48610973/458193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">深入解析：為什麼 <code class=\"gatsby-code-text\">setState()</code> 的呼叫會批次處理？什麼時候會如此？</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/11527#issuecomment-360199710\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">深入解析：為什麼 <code class=\"gatsby-code-text\">this.state</code> 不會馬上被更新？</a></li>\n</ul>\n<hr>\n<h3 id=\"forceupdate\"><a href=\"#forceupdate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">forceUpdate()</code> </h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\">component<span class=\"token punctuation\">.</span><span class=\"token function\">forceUpdate</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span></code></pre></div>\n<p>當你的 component 的 state 或 prop 改變的時候，你的 component 的預設行為是會重新 render。如果你的 <code class=\"gatsby-code-text\">render()</code> 方法還需要其他資料的話，你可以藉由呼叫 <code class=\"gatsby-code-text\">forceUpdate()</code> 來告訴 React 這個 component 需要重新 render。</p>\n<p>呼叫 <code class=\"gatsby-code-text\">forceUpdate()</code> 會導致  <code class=\"gatsby-code-text\">render()</code> 被呼叫於該 component 並跳過 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code>。這會觸發 children component 正常的生命週期方法，包含每個 child 的 <code class=\"gatsby-code-text\">shouldComponentUpdate()</code> 方法。React 依然只會在 markup 改變時更新 DOM。</p>\n<p>正常情況來說你應該避免使用 <code class=\"gatsby-code-text\">forceUpdate()</code> 並只從 <code class=\"gatsby-code-text\">render()</code> 中的 <code class=\"gatsby-code-text\">this.props</code> 和 <code class=\"gatsby-code-text\">this.state</code> 讀取。</p>\n<hr>\n<h2 id=\"class-properties-1\"><a href=\"#class-properties-1\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class 屬性 </h2>\n<h3 id=\"defaultprops\"><a href=\"#defaultprops\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">defaultProps</code> </h3>\n<p><code class=\"gatsby-code-text\">defaultProps</code> 可以在一個 component class 自身被定義為一個屬性，它被用來設定該 class 的預設 props。它是為了 <code class=\"gatsby-code-text\">undefined</code>（而非 <code class=\"gatsby-code-text\">null</code>） 的 prop 使用的。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomButton</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\nCustomButton<span class=\"token punctuation\">.</span>defaultProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  color<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果 <code class=\"gatsby-code-text\">props.color</code> 的值沒有被提供的話，它會被預設為 <code class=\"gatsby-code-text\">'blue'</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\">  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CustomButton</span></span> <span class=\"token punctuation\">/></span></span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// props.color 被預設為 blue</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果 <code class=\"gatsby-code-text\">props.color</code> 的值被設為 <code class=\"gatsby-code-text\">null</code>，其值會繼續為 <code class=\"gatsby-code-text\">null</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\">  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CustomButton</span></span> <span class=\"token attr-name\">color</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// props.color 繼續為 null</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h3 id=\"displayname\"><a href=\"#displayname\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">displayName</code> </h3>\n<p><code class=\"gatsby-code-text\">displayName</code> string 是用來 debug 的。通常，你不需要明確的設定這個屬性，因為它可以根據定義該 component 的 function 或 class 的名稱推斷這個值為何。當你為了 debug 或建立一個 higher-order component 而需要展示一個不同的名字時，你可能會想要明確的設定這個值，請參考<a href=\"/docs/higher-order-components.html#convention-wrap-the-display-name-for-easy-debugging\">如何包覆 Display Name 並輕鬆 debug</a>。</p>\n<hr>\n<h2 id=\"instance-properties-1\"><a href=\"#instance-properties-1\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Instance 屬性 </h2>\n<h3 id=\"props\"><a href=\"#props\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">props</code> </h3>\n<p><code class=\"gatsby-code-text\">this.props</code> 包含了該 component 的呼叫者所定義的 prop。想了解 prop 的基礎概念，請參考 <a href=\"/docs/components-and-props.html\">Components 和 Props</a>文件。</p>\n<p>值得注意的是，<code class=\"gatsby-code-text\">this.props.children</code> 是一個特別的 prop，通常在 JSX 表達式內的 child tag 內所定義，而不是其自身的 tag。</p>\n<h3 id=\"state\"><a href=\"#state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">state</code> </h3>\n<p>State 包含了某個 component 內特定的、會隨時間改變的資料，這個 state 是由使用者定義的。它應是一個簡單的 JavaScript object。</p>\n<p>如果某個值並沒有在 render 或資料流中被使用（例如計時器的 ID），你不需要將它放在 state 內。這類的值可以在 component 實例上被定義為 field。</p>\n<p>想更了解 state 如何運作，請參考 <a href=\"/docs/state-and-lifecycle.html\">State 和生命週期</a>。</p>\n<p>請永遠不要直接 mutate <code class=\"gatsby-code-text\">this.state</code>，因為後續的 <code class=\"gatsby-code-text\">setState()</code> 會替換掉你的 mutation。請將 <code class=\"gatsby-code-text\">this.state</code> 視為不可變的。</p>","frontmatter":{"title":"React.Component","next":null,"prev":null},"fields":{"path":"content/docs/reference-react-component.md","slug":"docs/react-component.html"}}},"pageContext":{"slug":"docs/react-component.html"}},"staticQueryHashes":[]}