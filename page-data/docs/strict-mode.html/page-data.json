{"componentChunkName":"component---src-templates-docs-js","path":"/docs/strict-mode.html","result":{"data":{"markdownRemark":{"html":"<p><code class=\"gatsby-code-text\">嚴格模式</code>是一個用來突顯應用程式裡潛在問題的工具。如同 <code class=\"gatsby-code-text\">Fragment</code> 一樣，<code class=\"gatsby-code-text\">嚴格模式</code>不會 render 任何可見的 UI。它為了底下的所有的依賴們啟動了額外的檢查和警告。</p>\n<blockquote>\n<p>注意：</p>\n<p>嚴格模式檢查只會在開發模式中執行；<em>它們不應該影響正式環境</em>。</p>\n</blockquote>\n<p>你可以在應用程式的任何地方打開嚴格模式。例如：<div class=\"gatsby-highlight\">\n        <pre class=\"gatsby-code-jsx\"><code><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">ExampleApplication</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Header</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">React.StrictMode</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentOne</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentTwo</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">React.StrictMode</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Footer</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n        </div></p>\n<p>在上面的範例裡，嚴格模式檢查將<em>不會</em>跑在 <code class=\"gatsby-code-text\">Header</code> 和 <code class=\"gatsby-code-text\">Footer</code> 元件上。然而 <code class=\"gatsby-code-text\">ComponentOne</code> 和 <code class=\"gatsby-code-text\">ComponentTwo</code>，以及它們底下的所有子依賴，都會被檢查。</p>\n<p><code class=\"gatsby-code-text\">嚴格模式</code>目前可以幫助：</p>\n<ul>\n<li><a href=\"#identifying-unsafe-lifecycles\">發現擁有不安全生命週期的 component</a></li>\n<li><a href=\"#warning-about-legacy-string-ref-api-usage\">警告使用了 legacy string ref API</a></li>\n<li><a href=\"#warning-about-deprecated-finddomnode-usage\">警告使用到了被棄用的 findDOMNode</a></li>\n<li><a href=\"#detecting-unexpected-side-effects\">偵測意想不到的副作用</a></li>\n<li><a href=\"#detecting-legacy-context-api\">偵測 legacy context API</a></li>\n</ul>\n<p>其他功能會在未來版本的 React 釋出時被加進去。</p>\n<h3 id=\"identifying-unsafe-lifecycles\"><a href=\"#identifying-unsafe-lifecycles\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>發現不安全的生命週期 </h3>\n<p>如<a href=\"/blog/2018/03/27/update-on-async-rendering.html\">這篇文章</a>所述，某些遺留的生命週期在非同步的 React 應用程式裡使用是不安全的。然而，如果你的應用程式使用到第三方套件，確認這些生命週期有沒有被使用到是很困難的。幸好嚴格模式可以在這點幫助我們！</p>\n<p>當嚴格模式被打開的時候，React 編譯了一整串用到這些不安全生命週期的 class component，然後記錄了這些 component 的警告訊息，例如：</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e4fdbff774b356881123e69ad88eda88/1628f/strict-mode-unsafe-lifecycles-warning.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 840px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 13.80952380952381%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAjElEQVQI112Oaw6CQAwGuf/RRBcJETWR8Fh5BNZkuUDHFkw0/pjka9NOm8jJIYcUSY87LkPOOXIpoa4R75G+h7aFpoFxhHWFGL9Y/SHBFlXA7Q7lFR4VdB5M5J977jqYJhgGlaq4qvaeoXPbMT1uJCHLWJwjFAUvFc/67ZznRPsmBGRZNixvWP6t//pvEpXgSjHsOOkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"strict mode unsafe lifecycles warning\"\n        title=\"\"\n        src=\"/static/e4fdbff774b356881123e69ad88eda88/1e088/strict-mode-unsafe-lifecycles-warning.png\"\n        srcset=\"/static/e4fdbff774b356881123e69ad88eda88/65ed1/strict-mode-unsafe-lifecycles-warning.png 210w,\n/static/e4fdbff774b356881123e69ad88eda88/d10fb/strict-mode-unsafe-lifecycles-warning.png 420w,\n/static/e4fdbff774b356881123e69ad88eda88/1e088/strict-mode-unsafe-lifecycles-warning.png 840w,\n/static/e4fdbff774b356881123e69ad88eda88/1628f/strict-mode-unsafe-lifecycles-warning.png 1232w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><em>現在</em> 就關注這些被嚴格模式所發現的問題，會幫助你在 React 將來的版本裡處理非同步 render 的時候更容易。</p>\n<h3 id=\"warning-about-legacy-string-ref-api-usage\"><a href=\"#warning-about-legacy-string-ref-api-usage\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>警告使用到了 legacy string ref API </h3>\n<p>以前 React 提供了兩種管理 ref 的方式：legacy string ref API 和 callback API。雖然 string ref API 在兩者之間是比較方便的，但它有很多<a href=\"https://github.com/facebook/react/issues/1373\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">缺點</a>，所以我們的官方推薦是<a href=\"/docs/refs-and-the-dom.html#legacy-api-string-refs\">使用 callback form</a>.</p>\n<p>React 16.3 加上了第三種選擇，提供了 string ref 的便利性且免除了那些缺點：\n<div class=\"gatsby-highlight\">\n        <pre class=\"gatsby-code-jsx\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>inputRef <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>inputRef<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>inputRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">focus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n        </div></p>\n<p>因為 object ref 已經大量取代了 string ref，嚴格模式現在會在你使用 string ref 的時候警告你。</p>\n<blockquote>\n<p><strong>注意：</strong></p>\n<p>除了新的 <code class=\"gatsby-code-text\">createRef</code> API 以外，callback ref 會持續被支援。</p>\n<p>你不需要改掉你 component 裡的 callback ref。它們稍微更有彈性，所以它們會持續是一個進階性的功能。</p>\n</blockquote>\n<p><a href=\"/docs/refs-and-the-dom.html\">學習更多關於新的 <code class=\"gatsby-code-text\">createRef</code> API。</a></p>\n<h3 id=\"warning-about-deprecated-finddomnode-usage\"><a href=\"#warning-about-deprecated-finddomnode-usage\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>警告使用到了被棄用的 findDOMNode </h3>\n<p>React 過去支援了 <code class=\"gatsby-code-text\">findDOMNode</code> 來用 class instance 搜尋 tree 裡面的 DOM 節點。通常你不需要這個，因為你可以 <a href=\"/docs/refs-and-the-dom.html#creating-refs\">直接把一個 ref 附到你的 DOM 節點</a>。</p>\n<p><code class=\"gatsby-code-text\">findDOMNode</code> 也可以被使用在 class component 上，但這是一個破壞抽象層的用法，它允許了 parent 來要求 render 某個特定的 children。它產生了重構的風險，因為 parent 可能會進入到某個 DOM 節點，所以你不能隨意改變 component 的實作細節。<code class=\"gatsby-code-text\">findDOMNode</code> 只會回傳第一個 child，但如果使用了 Fragment，有可能某個 component 會 render 多個 DOM 節點。<code class=\"gatsby-code-text\">findDOMNode</code> 是一個只能讀一次的 API。它只在你要求的時候告訴你答案。如果一個 child component render 了不同的節點，沒有任何方法可以處理這樣的改變。所以 <code class=\"gatsby-code-text\">findDOMNode</code> 只在元件永遠回傳一個單一且永遠不改變的 DOM 節點時有用。</p>\n<p>你可以藉由傳遞 ref 到你的客製化 component，且把它傳到使用 <a href=\"/docs/forwarding-refs.html#forwarding-refs-to-dom-components\">ref forwarding</a> 的 DOM，使它變得明顯。</p>\n<p>你也可以在你的 component 加上一個包裹的 DOM 節點，然後把 ref 直接附在它上面。</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>wrapper <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>wrapper<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>注意：</p>\n<p>在 CSS 裡，如果你不想要某個節點成為 layout 的一部份，<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">display: contents</code></a> attribute 可以被使用。</p>\n</blockquote>\n<h3 id=\"detecting-unexpected-side-effects\"><a href=\"#detecting-unexpected-side-effects\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>偵測意想不到的副作用 </h3>\n<p>概念上，React 在兩種面相上能夠運作：</p>\n<ul>\n<li><strong>render</strong> 面相決定了必須做出什麼改變到例如 DOM 的地方。在這個面相上，React 呼叫 <code class=\"gatsby-code-text\">render</code> 然後比較了它與上一次 render 的結果。</li>\n<li><strong>commit</strong> 面相是每當 React 運用到任何改變的時候。（在 React DOM 的例子，當 React 插入、更新、或移除 DOM 節點。）React 也在這個面相上呼叫了像是 <code class=\"gatsby-code-text\">componentDidMount</code> 和 <code class=\"gatsby-code-text\">componentDidUpdate</code> 的生命週期。</li>\n</ul>\n<p>Commit 面相通常非常快，但 render 可能會很慢。為了這個原因，將來的非同步模式（還沒被預設成開啟）會把 render 的工作切成小塊，暫停和恢復這些工作藉以避免阻擋瀏覽器。 這表示 React 可能會在 commit 之前調用多次 render 面相的生命週期，或是他會不管有沒有 commit 就調用它們（因為錯誤或是更高優先性的中斷）。</p>\n<p>Render 面相的生命週期包含了以下 class component 函式:</p>\n<ul>\n<li><code class=\"gatsby-code-text\">constructor</code></li>\n<li><code class=\"gatsby-code-text\">componentWillMount</code>（或 <code class=\"gatsby-code-text\">UNSAFE_componentWillMount</code>）</li>\n<li><code class=\"gatsby-code-text\">componentWillReceiveProps</code>（或 <code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps</code>）</li>\n<li><code class=\"gatsby-code-text\">componentWillUpdate</code>（或 <code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate</code>）</li>\n<li><code class=\"gatsby-code-text\">getDerivedStateFromProps</code></li>\n<li><code class=\"gatsby-code-text\">shouldComponentUpdate</code></li>\n<li><code class=\"gatsby-code-text\">render</code></li>\n<li><code class=\"gatsby-code-text\">setState</code> updater functions (第一個參數)</li>\n</ul>\n<p>因為以上函式可能會被呼叫不只一次，不包含副作用是很重要的。忽視這個規則可能會導致各種問題，包含記憶體滲漏，和不合法的應用程式 state。不幸的是，偵測這些問題很困難，因為它們通常是 <a href=\"https://en.wikipedia.org/wiki/Deterministic_algorithm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">non-deterministic</a>。</p>\n<p>嚴格模式無法自動檢測 side effect，但它可以藉由使這些 side effect 變得更有確定性，來幫助你發現它們。它藉由故意調用兩次下面的函式來完成這個功能：</p>\n<ul>\n<li>Class component <code class=\"gatsby-code-text\">constructor</code>、<code class=\"gatsby-code-text\">render</code> 和 <code class=\"gatsby-code-text\">shouldComponentUpdate</code> 方法</li>\n<li>Class component 的靜態 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 方法</li>\n<li>Function component 的內容</li>\n<li>狀態更新函式（<code class=\"gatsby-code-text\">setState</code> 的第一個參數）</li>\n<li>函數傳遞至 <code class=\"gatsby-code-text\">useState</code>、<code class=\"gatsby-code-text\">useMemo</code> 或 <code class=\"gatsby-code-text\">useReducer</code></li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<p>這個只在開發模式發生。<em>生命週期不會被重複調用在正式環境。</em></p>\n</blockquote>\n<p>例如，考慮以下程式碼：\n<div class=\"gatsby-highlight\">\n        <pre class=\"gatsby-code-jsx\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">TopLevelRoute</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    SharedApplicationState<span class=\"token punctuation\">.</span><span class=\"token function\">recordEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ExampleComponent'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n        </div></p>\n<p>第一眼看這段程式碼，可能不會覺得它有問題。但如果 <code class=\"gatsby-code-text\">SharedApplicationState.recordEvent</code> 不是 <a href=\"https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">idempotent</a> 的話，多次實體化這個 component 可能會導致不合法的應用程式 state。這種細微的錯誤可能在開發期間不會出現，或者會不一致地出現，因此被忽略了。</p>\n<p>通過有意地雙重調用如 component constructor，嚴格模式使這種模式更容易被發現。</p>\n<blockquote>\n<p>注意：</p>\n<p>從 React 17 開始，React 會自動更改如 <code class=\"gatsby-code-text\">console.log()</code> 的 console 方法，以在第二次調用生命週期函數時使 log 靜音，在某些情況下，它可能會導致無法預期的行為，你<a href=\"https://github.com/facebook/react/issues/20090#issuecomment-715927125\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">可以使用替代方案</a>。</p>\n</blockquote>\n<h3 id=\"detecting-legacy-context-api\"><a href=\"#detecting-legacy-context-api\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>檢測 legacy context API </h3>\n<p>Legacy context API 是容易出錯的，並將在以後的主要版本中刪除。它仍然適用於所有 16.x 版本，但將在嚴格模式下顯示以下警告訊息：</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fca5c5e1fb2ef2e2d59afb100b432c12/51800/warn-legacy-context-in-strict-mode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 840px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 18.57142857142857%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsklEQVQI1z2O226DMBBE+f8/axM3JGkL+AakkEixcUxfK2aybqVKR0c7LztT/eiGR4X3muqFpzfWe1jNwdEbOk0nNhg8ppFjD9uxt5wuWLNQId6hm023YnyeYdptidsjbakYhQXpF7nzozhFxIAlVPSWX0P5d5s5Txw8Lz2lYex5ndE18BbewGlIs2DaEmWL01U8qHSqxUHtlo9zqlU87IN6DV2zXmd+r38LCzmX5v+45iddvdtOYuXXpwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"warn legacy context in strict mode\"\n        title=\"\"\n        src=\"/static/fca5c5e1fb2ef2e2d59afb100b432c12/1e088/warn-legacy-context-in-strict-mode.png\"\n        srcset=\"/static/fca5c5e1fb2ef2e2d59afb100b432c12/65ed1/warn-legacy-context-in-strict-mode.png 210w,\n/static/fca5c5e1fb2ef2e2d59afb100b432c12/d10fb/warn-legacy-context-in-strict-mode.png 420w,\n/static/fca5c5e1fb2ef2e2d59afb100b432c12/1e088/warn-legacy-context-in-strict-mode.png 840w,\n/static/fca5c5e1fb2ef2e2d59afb100b432c12/51800/warn-legacy-context-in-strict-mode.png 1196w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>閱讀<a href=\"/docs/context.html\">新的 context API 文件</a>，以助於遷移到新版本。</p>","frontmatter":{"title":"嚴格模式","next":null,"prev":null},"fields":{"path":"content/docs/strict-mode.md","slug":"docs/strict-mode.html"}}},"pageContext":{"slug":"docs/strict-mode.html"}},"staticQueryHashes":[]}